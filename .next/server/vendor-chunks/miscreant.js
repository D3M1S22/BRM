"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/miscreant";
exports.ids = ["vendor-chunks/miscreant"];
exports.modules = {

/***/ "(rsc)/./node_modules/miscreant/release/aead.js":
/*!************************************************!*\
  !*** ./node_modules/miscreant/release/aead.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst webcrypto_1 = __webpack_require__(/*! ./providers/webcrypto */ \"(rsc)/./node_modules/miscreant/release/providers/webcrypto.js\");\nconst siv_1 = __webpack_require__(/*! ./siv */ \"(rsc)/./node_modules/miscreant/release/siv.js\");\n/** AEAD interface provider for ISIVLike types */\nclass AEAD {\n    /** Create a new AEAD instance with the given key */\n    static importKey(keyData, alg, provider = new webcrypto_1.WebCryptoProvider()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new AEAD(yield siv_1.SIV.importKey(keyData, alg, provider));\n        });\n    }\n    constructor(siv) {\n        this._siv = siv;\n    }\n    /** Encrypt and authenticate data using AES-SIV */\n    seal(plaintext, nonce, associatedData = new Uint8Array(0)) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._siv.seal(plaintext, [associatedData, nonce]);\n        });\n    }\n    /** Decrypt and authenticate data using AES-SIV */\n    open(ciphertext, nonce, associatedData = new Uint8Array(0)) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._siv.open(ciphertext, [associatedData, nonce]);\n        });\n    }\n    /** Make a best effort to wipe memory used by this instance */\n    clear() {\n        this._siv.clear();\n        return this;\n    }\n}\nexports.AEAD = AEAD;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvYWVhZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0MsaUVBQWlFLHdCQUF3QjtBQUN6SDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLDREQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvYWVhZC5qcz84MTkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB3ZWJjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy93ZWJjcnlwdG9cIik7XG5jb25zdCBzaXZfMSA9IHJlcXVpcmUoXCIuL3NpdlwiKTtcbi8qKiBBRUFEIGludGVyZmFjZSBwcm92aWRlciBmb3IgSVNJVkxpa2UgdHlwZXMgKi9cbmNsYXNzIEFFQUQge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgQUVBRCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBrZXkgKi9cbiAgICBzdGF0aWMgaW1wb3J0S2V5KGtleURhdGEsIGFsZywgcHJvdmlkZXIgPSBuZXcgd2ViY3J5cHRvXzEuV2ViQ3J5cHRvUHJvdmlkZXIoKSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBRUFEKHlpZWxkIHNpdl8xLlNJVi5pbXBvcnRLZXkoa2V5RGF0YSwgYWxnLCBwcm92aWRlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2l2KSB7XG4gICAgICAgIHRoaXMuX3NpdiA9IHNpdjtcbiAgICB9XG4gICAgLyoqIEVuY3J5cHQgYW5kIGF1dGhlbnRpY2F0ZSBkYXRhIHVzaW5nIEFFUy1TSVYgKi9cbiAgICBzZWFsKHBsYWludGV4dCwgbm9uY2UsIGFzc29jaWF0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoMCkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXYuc2VhbChwbGFpbnRleHQsIFthc3NvY2lhdGVkRGF0YSwgbm9uY2VdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBEZWNyeXB0IGFuZCBhdXRoZW50aWNhdGUgZGF0YSB1c2luZyBBRVMtU0lWICovXG4gICAgb3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgYXNzb2NpYXRlZERhdGEgPSBuZXcgVWludDhBcnJheSgwKSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Npdi5vcGVuKGNpcGhlcnRleHQsIFthc3NvY2lhdGVkRGF0YSwgbm9uY2VdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gd2lwZSBtZW1vcnkgdXNlZCBieSB0aGlzIGluc3RhbmNlICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX3Npdi5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkFFQUQgPSBBRUFEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/aead.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/exceptions.js":
/*!******************************************************!*\
  !*** ./node_modules/miscreant/release/exceptions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// tslint:disable:max-classes-per-file\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Thrown when ciphertext fails to verify as authentic */\nclass IntegrityError extends Error {\n    constructor(m) {\n        super(m);\n        Object.setPrototypeOf(this, IntegrityError.prototype);\n    }\n}\nexports.IntegrityError = IntegrityError;\n/** Thrown when we attempt to use an unsupported crypto algorithm via WebCrypto */\nclass NotImplementedError extends Error {\n    constructor(m) {\n        super(m);\n        Object.setPrototypeOf(this, NotImplementedError.prototype);\n    }\n}\nexports.NotImplementedError = NotImplementedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvZXhjZXB0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvZXhjZXB0aW9ucy5qcz9hY2FmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBUaHJvd24gd2hlbiBjaXBoZXJ0ZXh0IGZhaWxzIHRvIHZlcmlmeSBhcyBhdXRoZW50aWMgKi9cbmNsYXNzIEludGVncml0eUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0pIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBJbnRlZ3JpdHlFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZWdyaXR5RXJyb3IgPSBJbnRlZ3JpdHlFcnJvcjtcbi8qKiBUaHJvd24gd2hlbiB3ZSBhdHRlbXB0IHRvIHVzZSBhbiB1bnN1cHBvcnRlZCBjcnlwdG8gYWxnb3JpdGhtIHZpYSBXZWJDcnlwdG8gKi9cbmNsYXNzIE5vdEltcGxlbWVudGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobSkge1xuICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE5vdEltcGxlbWVudGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdEltcGxlbWVudGVkRXJyb3IgPSBOb3RJbXBsZW1lbnRlZEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/exceptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/index.js":
/*!*************************************************!*\
  !*** ./node_modules/miscreant/release/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Exceptions */\n__export(__webpack_require__(/*! ./exceptions */ \"(rsc)/./node_modules/miscreant/release/exceptions.js\"));\n/** Symmetric encryption APIs */\nvar aead_1 = __webpack_require__(/*! ./aead */ \"(rsc)/./node_modules/miscreant/release/aead.js\");\nexports.AEAD = aead_1.AEAD;\nvar siv_1 = __webpack_require__(/*! ./siv */ \"(rsc)/./node_modules/miscreant/release/siv.js\");\nexports.SIV = siv_1.SIV;\n/** STREAM streaming encryption */\nvar stream_1 = __webpack_require__(/*! ./stream */ \"(rsc)/./node_modules/miscreant/release/stream.js\");\nexports.StreamEncryptor = stream_1.StreamEncryptor;\nexports.StreamDecryptor = stream_1.StreamDecryptor;\n/** MAC functions */\nvar cmac_1 = __webpack_require__(/*! ./mac/cmac */ \"(rsc)/./node_modules/miscreant/release/mac/cmac.js\");\nexports.CMAC = cmac_1.CMAC;\nvar pmac_1 = __webpack_require__(/*! ./mac/pmac */ \"(rsc)/./node_modules/miscreant/release/mac/pmac.js\");\nexports.PMAC = pmac_1.PMAC;\n/** Crypto providers */\nvar polyfill_1 = __webpack_require__(/*! ./providers/polyfill */ \"(rsc)/./node_modules/miscreant/release/providers/polyfill.js\");\nexports.PolyfillCryptoProvider = polyfill_1.PolyfillCryptoProvider;\nvar webcrypto_1 = __webpack_require__(/*! ./providers/webcrypto */ \"(rsc)/./node_modules/miscreant/release/providers/webcrypto.js\");\nexports.WebCryptoProvider = webcrypto_1.WebCryptoProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSxTQUFTLG1CQUFPLENBQUMsMEVBQWM7QUFDL0I7QUFDQSxhQUFhLG1CQUFPLENBQUMsOERBQVE7QUFDN0IsWUFBWTtBQUNaLFlBQVksbUJBQU8sQ0FBQyw0REFBTztBQUMzQixXQUFXO0FBQ1g7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0VBQVU7QUFDakMsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzRUFBWTtBQUNqQyxZQUFZO0FBQ1osYUFBYSxtQkFBTyxDQUFDLHNFQUFZO0FBQ2pDLFlBQVk7QUFDWjtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDBGQUFzQjtBQUMvQyw4QkFBOEI7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ2pELHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL2luZGV4LmpzP2MyZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEV4Y2VwdGlvbnMgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2V4Y2VwdGlvbnNcIikpO1xuLyoqIFN5bW1ldHJpYyBlbmNyeXB0aW9uIEFQSXMgKi9cbnZhciBhZWFkXzEgPSByZXF1aXJlKFwiLi9hZWFkXCIpO1xuZXhwb3J0cy5BRUFEID0gYWVhZF8xLkFFQUQ7XG52YXIgc2l2XzEgPSByZXF1aXJlKFwiLi9zaXZcIik7XG5leHBvcnRzLlNJViA9IHNpdl8xLlNJVjtcbi8qKiBTVFJFQU0gc3RyZWFtaW5nIGVuY3J5cHRpb24gKi9cbnZhciBzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbVwiKTtcbmV4cG9ydHMuU3RyZWFtRW5jcnlwdG9yID0gc3RyZWFtXzEuU3RyZWFtRW5jcnlwdG9yO1xuZXhwb3J0cy5TdHJlYW1EZWNyeXB0b3IgPSBzdHJlYW1fMS5TdHJlYW1EZWNyeXB0b3I7XG4vKiogTUFDIGZ1bmN0aW9ucyAqL1xudmFyIGNtYWNfMSA9IHJlcXVpcmUoXCIuL21hYy9jbWFjXCIpO1xuZXhwb3J0cy5DTUFDID0gY21hY18xLkNNQUM7XG52YXIgcG1hY18xID0gcmVxdWlyZShcIi4vbWFjL3BtYWNcIik7XG5leHBvcnRzLlBNQUMgPSBwbWFjXzEuUE1BQztcbi8qKiBDcnlwdG8gcHJvdmlkZXJzICovXG52YXIgcG9seWZpbGxfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9wb2x5ZmlsbFwiKTtcbmV4cG9ydHMuUG9seWZpbGxDcnlwdG9Qcm92aWRlciA9IHBvbHlmaWxsXzEuUG9seWZpbGxDcnlwdG9Qcm92aWRlcjtcbnZhciB3ZWJjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy93ZWJjcnlwdG9cIik7XG5leHBvcnRzLldlYkNyeXB0b1Byb3ZpZGVyID0gd2ViY3J5cHRvXzEuV2ViQ3J5cHRvUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/internals/block.js":
/*!***********************************************************!*\
  !*** ./node_modules/miscreant/release/internals/block.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/** Type which represents AES blocks */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst constant_time_1 = __webpack_require__(/*! ./constant-time */ \"(rsc)/./node_modules/miscreant/release/internals/constant-time.js\");\nconst wipe_1 = __webpack_require__(/*! ./wipe */ \"(rsc)/./node_modules/miscreant/release/internals/wipe.js\");\n/** An AES block (128-bits) */\nclass Block {\n    constructor() {\n        this.data = new Uint8Array(Block.SIZE);\n    }\n    /**\n     * Clear the given array by setting its values to zero.\n     *\n     * WARNING: The fact that it sets bytes to zero can be relied on.\n     *\n     * There is no guarantee that this function makes data disappear from memory,\n     * as runtime implementation can, for example, have copying garbage collector\n     * that will make copies of sensitive data before we wipe it. Or that an\n     * operating system will write our data to swap or sleep image. Another thing\n     * is that an optimizing compiler can remove calls to this function or make it\n     * no-op. There's nothing we can do with it, so we just do our best and hope\n     * that everything will be okay and good will triumph over evil.\n     */\n    clear() {\n        wipe_1.wipe(this.data);\n    }\n    /**\n     * Make a copy of this block, returning a new block\n     */\n    clone() {\n        const ret = new Block();\n        ret.copy(this);\n        return ret;\n    }\n    /** Copy the contents of another block into this one */\n    copy(other) {\n        this.data.set(other.data);\n    }\n    /**\n     * Double a value over GF(2^128):\n     *\n     *     a<<1 if firstbit(a)=0\n     *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n     */\n    dbl() {\n        let carry = 0;\n        for (let i = Block.SIZE - 1; i >= 0; i--) {\n            const b = (this.data[i] >>> 7) & 0xff;\n            this.data[i] = (this.data[i] << 1) | carry;\n            carry = b;\n        }\n        this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n        carry = 0;\n    }\n}\n/** Size of a block as used by the AES cipher */\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\nBlock.R = 0x87;\nexports[\"default\"] = Block;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvaW50ZXJuYWxzL2Jsb2NrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsMEZBQWlCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyx3RUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taXNjcmVhbnQvcmVsZWFzZS9pbnRlcm5hbHMvYmxvY2suanM/ZjU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKiBUeXBlIHdoaWNoIHJlcHJlc2VudHMgQUVTIGJsb2NrcyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RhbnRfdGltZV8xID0gcmVxdWlyZShcIi4vY29uc3RhbnQtdGltZVwiKTtcbmNvbnN0IHdpcGVfMSA9IHJlcXVpcmUoXCIuL3dpcGVcIik7XG4vKiogQW4gQUVTIGJsb2NrICgxMjgtYml0cykgKi9cbmNsYXNzIEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoQmxvY2suU0laRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBnaXZlbiBhcnJheSBieSBzZXR0aW5nIGl0cyB2YWx1ZXMgdG8gemVyby5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IFRoZSBmYWN0IHRoYXQgaXQgc2V0cyBieXRlcyB0byB6ZXJvIGNhbiBiZSByZWxpZWQgb24uXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGlzIGZ1bmN0aW9uIG1ha2VzIGRhdGEgZGlzYXBwZWFyIGZyb20gbWVtb3J5LFxuICAgICAqIGFzIHJ1bnRpbWUgaW1wbGVtZW50YXRpb24gY2FuLCBmb3IgZXhhbXBsZSwgaGF2ZSBjb3B5aW5nIGdhcmJhZ2UgY29sbGVjdG9yXG4gICAgICogdGhhdCB3aWxsIG1ha2UgY29waWVzIG9mIHNlbnNpdGl2ZSBkYXRhIGJlZm9yZSB3ZSB3aXBlIGl0LiBPciB0aGF0IGFuXG4gICAgICogb3BlcmF0aW5nIHN5c3RlbSB3aWxsIHdyaXRlIG91ciBkYXRhIHRvIHN3YXAgb3Igc2xlZXAgaW1hZ2UuIEFub3RoZXIgdGhpbmdcbiAgICAgKiBpcyB0aGF0IGFuIG9wdGltaXppbmcgY29tcGlsZXIgY2FuIHJlbW92ZSBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIG9yIG1ha2UgaXRcbiAgICAgKiBuby1vcC4gVGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbyB3aXRoIGl0LCBzbyB3ZSBqdXN0IGRvIG91ciBiZXN0IGFuZCBob3BlXG4gICAgICogdGhhdCBldmVyeXRoaW5nIHdpbGwgYmUgb2theSBhbmQgZ29vZCB3aWxsIHRyaXVtcGggb3ZlciBldmlsLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB3aXBlXzEud2lwZSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgY29weSBvZiB0aGlzIGJsb2NrLCByZXR1cm5pbmcgYSBuZXcgYmxvY2tcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEJsb2NrKCk7XG4gICAgICAgIHJldC5jb3B5KHRoaXMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKiogQ29weSB0aGUgY29udGVudHMgb2YgYW5vdGhlciBibG9jayBpbnRvIHRoaXMgb25lICovXG4gICAgY29weShvdGhlcikge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KG90aGVyLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3VibGUgYSB2YWx1ZSBvdmVyIEdGKDJeMTI4KTpcbiAgICAgKlxuICAgICAqICAgICBhPDwxIGlmIGZpcnN0Yml0KGEpPTBcbiAgICAgKiAgICAgKGE8PDEpIOKKlSAwwrnCsuKBsDEwMDAwMTExIGlmIGZpcnN0Yml0KGEpPTFcbiAgICAgKi9cbiAgICBkYmwoKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBCbG9jay5TSVpFIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodGhpcy5kYXRhW2ldID4+PiA3KSAmIDB4ZmY7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSAodGhpcy5kYXRhW2ldIDw8IDEpIHwgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhW0Jsb2NrLlNJWkUgLSAxXSBePSBjb25zdGFudF90aW1lXzEuc2VsZWN0KGNhcnJ5LCBCbG9jay5SLCAwKTtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgIH1cbn1cbi8qKiBTaXplIG9mIGEgYmxvY2sgYXMgdXNlZCBieSB0aGUgQUVTIGNpcGhlciAqL1xuQmxvY2suU0laRSA9IDE2O1xuLyoqIE1pbmltYWwgaXJyZWR1Y2libGUgcG9seW5vbWlhbCBmb3IgYSAxMjgtYml0IGJsb2NrIHNpemUgKi9cbkJsb2NrLlIgPSAweDg3O1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/internals/block.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/internals/constant-time.js":
/*!*******************************************************************!*\
  !*** ./node_modules/miscreant/release/internals/constant-time.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * NOTE! Due to the inability to guarantee real constant time evaluation of\n * anything in JavaScript VM, this is module is the best effort.\n */\n/**\n * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.\n *\n * Supports only 32-bit integers, so resultIfOne or resultIfZero are not\n * integers, they'll be converted to them with bitwise operations.\n */\nfunction select(subject, resultIfOne, resultIfZero) {\n    return (~(subject - 1) & resultIfOne) | ((subject - 1) & resultIfZero);\n}\nexports.select = select;\n/**\n * Returns 1 if a and b are of equal length and their contents\n * are equal, or 0 otherwise.\n *\n * Note that unlike in equal(), zero-length inputs are considered\n * the same, so this function will return 1.\n */\nfunction compare(a, b) {\n    if (a.length !== b.length) {\n        return 0;\n    }\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n        result |= a[i] ^ b[i];\n    }\n    return (1 & ((result - 1) >>> 8));\n}\nexports.compare = compare;\n/**\n * Returns true if a and b are of equal non-zero length,\n * and their contents are equal, or false otherwise.\n *\n * Note that unlike in compare() zero-length inputs are considered\n * _not_ equal, so this function will return false.\n */\nfunction equal(a, b) {\n    if (a.length === 0 || b.length === 0) {\n        return false;\n    }\n    return compare(a, b) !== 0;\n}\nexports.equal = equal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvaW50ZXJuYWxzL2NvbnN0YW50LXRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL2ludGVybmFscy9jb25zdGFudC10aW1lLmpzP2IzYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE5PVEUhIER1ZSB0byB0aGUgaW5hYmlsaXR5IHRvIGd1YXJhbnRlZSByZWFsIGNvbnN0YW50IHRpbWUgZXZhbHVhdGlvbiBvZlxuICogYW55dGhpbmcgaW4gSmF2YVNjcmlwdCBWTSwgdGhpcyBpcyBtb2R1bGUgaXMgdGhlIGJlc3QgZWZmb3J0LlxuICovXG4vKipcbiAqIFJldHVybnMgcmVzdWx0SWZPbmUgaWYgc3ViamVjdCBpcyAxLCBvciByZXN1bHRJZlplcm8gaWYgc3ViamVjdCBpcyAwLlxuICpcbiAqIFN1cHBvcnRzIG9ubHkgMzItYml0IGludGVnZXJzLCBzbyByZXN1bHRJZk9uZSBvciByZXN1bHRJZlplcm8gYXJlIG5vdFxuICogaW50ZWdlcnMsIHRoZXknbGwgYmUgY29udmVydGVkIHRvIHRoZW0gd2l0aCBiaXR3aXNlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdChzdWJqZWN0LCByZXN1bHRJZk9uZSwgcmVzdWx0SWZaZXJvKSB7XG4gICAgcmV0dXJuICh+KHN1YmplY3QgLSAxKSAmIHJlc3VsdElmT25lKSB8ICgoc3ViamVjdCAtIDEpICYgcmVzdWx0SWZaZXJvKTtcbn1cbmV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuLyoqXG4gKiBSZXR1cm5zIDEgaWYgYSBhbmQgYiBhcmUgb2YgZXF1YWwgbGVuZ3RoIGFuZCB0aGVpciBjb250ZW50c1xuICogYXJlIGVxdWFsLCBvciAwIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlIHRoYXQgdW5saWtlIGluIGVxdWFsKCksIHplcm8tbGVuZ3RoIGlucHV0cyBhcmUgY29uc2lkZXJlZFxuICogdGhlIHNhbWUsIHNvIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gMS5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCB8PSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuICgxICYgKChyZXN1bHQgLSAxKSA+Pj4gOCkpO1xufVxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgYW5kIGIgYXJlIG9mIGVxdWFsIG5vbi16ZXJvIGxlbmd0aCxcbiAqIGFuZCB0aGVpciBjb250ZW50cyBhcmUgZXF1YWwsIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlIHRoYXQgdW5saWtlIGluIGNvbXBhcmUoKSB6ZXJvLWxlbmd0aCBpbnB1dHMgYXJlIGNvbnNpZGVyZWRcbiAqIF9ub3RfIGVxdWFsLCBzbyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwIHx8IGIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmUoYSwgYikgIT09IDA7XG59XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/internals/constant-time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/internals/ctz.js":
/*!*********************************************************!*\
  !*** ./node_modules/miscreant/release/internals/ctz.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Number of trailing zeros in a given byte value */\nconst CTZ_TABLE = new Uint8Array([\n    8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n]);\n/** Count the number of trailing zeroes in a given number */\nfunction ctz(value) {\n    return CTZ_TABLE[value];\n}\nexports.ctz = ctz;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvaW50ZXJuYWxzL2N0ei5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL2ludGVybmFscy9jdHouanM/YTNiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBOdW1iZXIgb2YgdHJhaWxpbmcgemVyb3MgaW4gYSBnaXZlbiBieXRlIHZhbHVlICovXG5jb25zdCBDVFpfVEFCTEUgPSBuZXcgVWludDhBcnJheShbXG4gICAgOCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCxcbiAgICA0LCAwLCAxLCAwLCAyLCAwLCAxLCAwLCAzLCAwLCAxLCAwLCAyLCAwLCAxLCAwLFxuICAgIDUsIDAsIDEsIDAsIDIsIDAsIDEsIDAsIDMsIDAsIDEsIDAsIDIsIDAsIDEsIDAsXG4gICAgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCxcbiAgICA2LCAwLCAxLCAwLCAyLCAwLCAxLCAwLCAzLCAwLCAxLCAwLCAyLCAwLCAxLCAwLFxuICAgIDQsIDAsIDEsIDAsIDIsIDAsIDEsIDAsIDMsIDAsIDEsIDAsIDIsIDAsIDEsIDAsXG4gICAgNSwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCxcbiAgICA0LCAwLCAxLCAwLCAyLCAwLCAxLCAwLCAzLCAwLCAxLCAwLCAyLCAwLCAxLCAwLFxuICAgIDcsIDAsIDEsIDAsIDIsIDAsIDEsIDAsIDMsIDAsIDEsIDAsIDIsIDAsIDEsIDAsXG4gICAgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCxcbiAgICA1LCAwLCAxLCAwLCAyLCAwLCAxLCAwLCAzLCAwLCAxLCAwLCAyLCAwLCAxLCAwLFxuICAgIDQsIDAsIDEsIDAsIDIsIDAsIDEsIDAsIDMsIDAsIDEsIDAsIDIsIDAsIDEsIDAsXG4gICAgNiwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCxcbiAgICA0LCAwLCAxLCAwLCAyLCAwLCAxLCAwLCAzLCAwLCAxLCAwLCAyLCAwLCAxLCAwLFxuICAgIDUsIDAsIDEsIDAsIDIsIDAsIDEsIDAsIDMsIDAsIDEsIDAsIDIsIDAsIDEsIDAsXG4gICAgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCxcbl0pO1xuLyoqIENvdW50IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb2VzIGluIGEgZ2l2ZW4gbnVtYmVyICovXG5mdW5jdGlvbiBjdHoodmFsdWUpIHtcbiAgICByZXR1cm4gQ1RaX1RBQkxFW3ZhbHVlXTtcbn1cbmV4cG9ydHMuY3R6ID0gY3R6O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/internals/ctz.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/internals/wipe.js":
/*!**********************************************************!*\
  !*** ./node_modules/miscreant/release/internals/wipe.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nfunction wipe(array) {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (let i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\nexports.wipe = wipe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvaW50ZXJuYWxzL3dpcGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL2ludGVybmFscy93aXBlLmpzPzYyODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNldHMgYWxsIHZhbHVlcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdG8gemVybyBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBUaGUgZmFjdCB0aGF0IGl0IHNldHMgYnl0ZXMgdG8gemVybyBjYW4gYmUgcmVsaWVkIG9uLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoaXMgZnVuY3Rpb24gbWFrZXMgZGF0YSBkaXNhcHBlYXIgZnJvbSBtZW1vcnksXG4gKiBhcyBydW50aW1lIGltcGxlbWVudGF0aW9uIGNhbiwgZm9yIGV4YW1wbGUsIGhhdmUgY29weWluZyBnYXJiYWdlIGNvbGxlY3RvclxuICogdGhhdCB3aWxsIG1ha2UgY29waWVzIG9mIHNlbnNpdGl2ZSBkYXRhIGJlZm9yZSB3ZSB3aXBlIGl0LiBPciB0aGF0IGFuXG4gKiBvcGVyYXRpbmcgc3lzdGVtIHdpbGwgd3JpdGUgb3VyIGRhdGEgdG8gc3dhcCBvciBzbGVlcCBpbWFnZS4gQW5vdGhlciB0aGluZ1xuICogaXMgdGhhdCBhbiBvcHRpbWl6aW5nIGNvbXBpbGVyIGNhbiByZW1vdmUgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiBvciBtYWtlIGl0XG4gKiBuby1vcC4gVGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbyB3aXRoIGl0LCBzbyB3ZSBqdXN0IGRvIG91ciBiZXN0IGFuZCBob3BlXG4gKiB0aGF0IGV2ZXJ5dGhpbmcgd2lsbCBiZSBva2F5IGFuZCBnb29kIHdpbGwgdHJpdW1waCBvdmVyIGV2aWwuXG4gKi9cbmZ1bmN0aW9uIHdpcGUoYXJyYXkpIHtcbiAgICAvLyBSaWdodCBub3cgaXQncyBzaW1pbGFyIHRvIGFycmF5LmZpbGwoMCkuIElmIGl0IHR1cm5zXG4gICAgLy8gb3V0IHRoYXQgcnVudGltZXMgb3B0aW1pemUgdGhpcyBjYWxsIGF3YXksIG1heWJlXG4gICAgLy8gd2UgY2FuIHRyeSBzb21ldGhpbmcgZWxzZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy53aXBlID0gd2lwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/internals/wipe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/internals/xor.js":
/*!*********************************************************!*\
  !*** ./node_modules/miscreant/release/internals/xor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Perform an in-place bitwise XOR operation on two bytestrings */\nfunction xor(a, b) {\n    for (let i = 0; i < b.length; i++) {\n        a[i] ^= b[i];\n    }\n}\nexports.xor = xor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvaW50ZXJuYWxzL3hvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taXNjcmVhbnQvcmVsZWFzZS9pbnRlcm5hbHMveG9yLmpzP2JiYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogUGVyZm9ybSBhbiBpbi1wbGFjZSBiaXR3aXNlIFhPUiBvcGVyYXRpb24gb24gdHdvIGJ5dGVzdHJpbmdzICovXG5mdW5jdGlvbiB4b3IoYSwgYikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW2ldIF49IGJbaV07XG4gICAgfVxufVxuZXhwb3J0cy54b3IgPSB4b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/internals/xor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/mac/cmac.js":
/*!****************************************************!*\
  !*** ./node_modules/miscreant/release/mac/cmac.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst block_1 = __webpack_require__(/*! ../internals/block */ \"(rsc)/./node_modules/miscreant/release/internals/block.js\");\nconst xor_1 = __webpack_require__(/*! ../internals/xor */ \"(rsc)/./node_modules/miscreant/release/internals/xor.js\");\n/**\n * The AES-CMAC message authentication code\n */\nclass CMAC {\n    constructor(_cipher, _subkey1, _subkey2) {\n        this._cipher = _cipher;\n        this._subkey1 = _subkey1;\n        this._subkey2 = _subkey2;\n        this._bufferPos = 0;\n        this._finished = false;\n        this._buffer = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            // Generate subkeys.\n            const subkey1 = new block_1.default();\n            yield cipher.encryptBlock(subkey1);\n            subkey1.dbl();\n            const subkey2 = subkey1.clone();\n            subkey2.dbl();\n            return new CMAC(cipher, subkey1, subkey2);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._subkey1.clear();\n        this._subkey2.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            if (dataLength > left) {\n                for (let i = 0; i < left; i++) {\n                    this._buffer.data[this._bufferPos + i] ^= data[i];\n                }\n                dataLength -= left;\n                dataPos += left;\n                yield this._cipher.encryptBlock(this._buffer);\n                this._bufferPos = 0;\n            }\n            // TODO: use AES-CBC with a span of multiple blocks instead of encryptBlock\n            // to encrypt many blocks in a single call to the WebCrypto API\n            while (dataLength > block_1.default.SIZE) {\n                for (let i = 0; i < block_1.default.SIZE; i++) {\n                    this._buffer.data[i] ^= data[dataPos + i];\n                }\n                dataLength -= block_1.default.SIZE;\n                dataPos += block_1.default.SIZE;\n                yield this._cipher.encryptBlock(this._buffer);\n            }\n            for (let i = 0; i < dataLength; i++) {\n                this._buffer.data[this._bufferPos++] ^= data[dataPos + i];\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._finished) {\n                // Select which subkey to use.\n                const subkey = (this._bufferPos < block_1.default.SIZE) ? this._subkey2 : this._subkey1;\n                // XOR in the subkey.\n                xor_1.xor(this._buffer.data, subkey.data);\n                // Pad if needed.\n                if (this._bufferPos < block_1.default.SIZE) {\n                    this._buffer.data[this._bufferPos] ^= 0x80;\n                }\n                // Encrypt buffer to get the final digest.\n                yield this._cipher.encryptBlock(this._buffer);\n                // Set finished flag.\n                this._finished = true;\n            }\n            return this._buffer.clone().data;\n        });\n    }\n}\nexports.CMAC = CMAC;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvbWFjL2NtYWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHFGQUFvQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL21hYy9jbWFjLmpzP2ZhY2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyBEbWl0cnkgQ2hlc3RueWtoLCBUb255IEFyY2llcmlcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBibG9ja18xID0gcmVxdWlyZShcIi4uL2ludGVybmFscy9ibG9ja1wiKTtcbmNvbnN0IHhvcl8xID0gcmVxdWlyZShcIi4uL2ludGVybmFscy94b3JcIik7XG4vKipcbiAqIFRoZSBBRVMtQ01BQyBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGVcbiAqL1xuY2xhc3MgQ01BQyB7XG4gICAgY29uc3RydWN0b3IoX2NpcGhlciwgX3N1YmtleTEsIF9zdWJrZXkyKSB7XG4gICAgICAgIHRoaXMuX2NpcGhlciA9IF9jaXBoZXI7XG4gICAgICAgIHRoaXMuX3N1YmtleTEgPSBfc3Via2V5MTtcbiAgICAgICAgdGhpcy5fc3Via2V5MiA9IF9zdWJrZXkyO1xuICAgICAgICB0aGlzLl9idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgYmxvY2tfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgYSBuZXcgQ01BQyBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBrZXkgKi9cbiAgICBzdGF0aWMgaW1wb3J0S2V5KHByb3ZpZGVyLCBrZXlEYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXIgPSB5aWVsZCBwcm92aWRlci5pbXBvcnRCbG9ja0NpcGhlcktleShrZXlEYXRhKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHN1YmtleXMuXG4gICAgICAgICAgICBjb25zdCBzdWJrZXkxID0gbmV3IGJsb2NrXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgeWllbGQgY2lwaGVyLmVuY3J5cHRCbG9jayhzdWJrZXkxKTtcbiAgICAgICAgICAgIHN1YmtleTEuZGJsKCk7XG4gICAgICAgICAgICBjb25zdCBzdWJrZXkyID0gc3Via2V5MS5jbG9uZSgpO1xuICAgICAgICAgICAgc3Via2V5Mi5kYmwoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ01BQyhjaXBoZXIsIHN1YmtleTEsIHN1YmtleTIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlci5jbGVhcigpO1xuICAgICAgICB0aGlzLl9idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fc3Via2V5MS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9zdWJrZXkyLmNsZWFyKCk7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gYmxvY2tfMS5kZWZhdWx0LlNJWkUgLSB0aGlzLl9idWZmZXJQb3M7XG4gICAgICAgICAgICBsZXQgZGF0YVBvcyA9IDA7XG4gICAgICAgICAgICBsZXQgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGggPiBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLmRhdGFbdGhpcy5fYnVmZmVyUG9zICsgaV0gXj0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aCAtPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGRhdGFQb3MgKz0gbGVmdDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBBRVMtQ0JDIHdpdGggYSBzcGFuIG9mIG11bHRpcGxlIGJsb2NrcyBpbnN0ZWFkIG9mIGVuY3J5cHRCbG9ja1xuICAgICAgICAgICAgLy8gdG8gZW5jcnlwdCBtYW55IGJsb2NrcyBpbiBhIHNpbmdsZSBjYWxsIHRvIHRoZSBXZWJDcnlwdG8gQVBJXG4gICAgICAgICAgICB3aGlsZSAoZGF0YUxlbmd0aCA+IGJsb2NrXzEuZGVmYXVsdC5TSVpFKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja18xLmRlZmF1bHQuU0laRTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5kYXRhW2ldIF49IGRhdGFbZGF0YVBvcyArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhTGVuZ3RoIC09IGJsb2NrXzEuZGVmYXVsdC5TSVpFO1xuICAgICAgICAgICAgICAgIGRhdGFQb3MgKz0gYmxvY2tfMS5kZWZhdWx0LlNJWkU7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIuZGF0YVt0aGlzLl9idWZmZXJQb3MrK10gXj0gZGF0YVtkYXRhUG9zICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3Qgd2hpY2ggc3Via2V5IHRvIHVzZS5cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJrZXkgPSAodGhpcy5fYnVmZmVyUG9zIDwgYmxvY2tfMS5kZWZhdWx0LlNJWkUpID8gdGhpcy5fc3Via2V5MiA6IHRoaXMuX3N1YmtleTE7XG4gICAgICAgICAgICAgICAgLy8gWE9SIGluIHRoZSBzdWJrZXkuXG4gICAgICAgICAgICAgICAgeG9yXzEueG9yKHRoaXMuX2J1ZmZlci5kYXRhLCBzdWJrZXkuZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gUGFkIGlmIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVyUG9zIDwgYmxvY2tfMS5kZWZhdWx0LlNJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLmRhdGFbdGhpcy5fYnVmZmVyUG9zXSBePSAweDgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbmNyeXB0IGJ1ZmZlciB0byBnZXQgdGhlIGZpbmFsIGRpZ2VzdC5cbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGZpbmlzaGVkIGZsYWcuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5jbG9uZSgpLmRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ01BQyA9IENNQUM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/mac/cmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/mac/pmac.js":
/*!****************************************************!*\
  !*** ./node_modules/miscreant/release/mac/pmac.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst block_1 = __webpack_require__(/*! ../internals/block */ \"(rsc)/./node_modules/miscreant/release/internals/block.js\");\nconst constant_time_1 = __webpack_require__(/*! ../internals/constant-time */ \"(rsc)/./node_modules/miscreant/release/internals/constant-time.js\");\nconst ctz_1 = __webpack_require__(/*! ../internals/ctz */ \"(rsc)/./node_modules/miscreant/release/internals/ctz.js\");\nconst xor_1 = __webpack_require__(/*! ../internals/xor */ \"(rsc)/./node_modules/miscreant/release/internals/xor.js\");\n// Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\nconst PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\nclass PMAC {\n    constructor(cipher, l, lInv) {\n        /**\n         * finished is set true when we are done processing a message, and forbids\n         * any subsequent writes until we reset the internal state\n         */\n        this._finished = false;\n        this._cipher = cipher;\n        this._L = l;\n        this._LInv = lInv;\n        this._buffer = new block_1.default();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset = new block_1.default();\n        this._tag = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            /**\n             * L is defined as follows (quoted from the PMAC paper):\n             *\n             * Equation 1:\n             *\n             *     a · x =\n             *         a<<1 if firstbit(a)=0\n             *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n             *\n             * Equation 2:\n             *\n             *     a · x⁻¹ =\n             *         a>>1 if lastbit(a)=0\n             *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             *\n             * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n             * Equation (1) using a shift and a conditional xor.\n             *\n             * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n             * conditional xor.\n             *\n             * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n             * (Alternatively, [ed: as we have done in this codebase] defer computing\n             * some or  all of these L(i) values until the value is actually needed.)\n             */\n            const tmp = new block_1.default();\n            yield cipher.encryptBlock(tmp);\n            const l = new Array(PRECOMPUTED_BLOCKS);\n            for (let i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n                l[i] = tmp.clone();\n                tmp.dbl();\n            }\n            /**\n             * Compute L(−1) ← L · x⁻¹:\n             *\n             *     a>>1 if lastbit(a)=0\n             *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             */\n            const lInv = l[0].clone();\n            const lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n            for (let i = block_1.default.SIZE - 1; i > 0; i--) {\n                const carry = constant_time_1.select(lInv.data[i - 1] & 1, 0x80, 0);\n                lInv.data[i] = (lInv.data[i] >>> 1) | carry;\n            }\n            lInv.data[0] >>>= 1;\n            lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n            lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n            return new PMAC(cipher, l, lInv);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset.clear();\n        this._tag.clear();\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._cipher.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            // Finish filling the internal buf with the message\n            if (dataLength > left) {\n                this._buffer.data.set(data.slice(0, left), this._bufferPos);\n                dataPos += left;\n                dataLength -= left;\n                yield this._processBuffer();\n            }\n            // So long as we have more than a blocks worth of data, compute\n            // whole-sized blocks at a time.\n            while (dataLength > block_1.default.SIZE) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n                dataPos += block_1.default.SIZE;\n                dataLength -= block_1.default.SIZE;\n                yield this._processBuffer();\n            }\n            if (dataLength > 0) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n                this._bufferPos += dataLength;\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            if (this._bufferPos === block_1.default.SIZE) {\n                xor_1.xor(this._tag.data, this._buffer.data);\n                xor_1.xor(this._tag.data, this._LInv.data);\n            }\n            else {\n                xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n                this._tag.data[this._bufferPos] ^= 0x80;\n            }\n            yield this._cipher.encryptBlock(this._tag);\n            this._finished = true;\n            return this._tag.clone().data;\n        });\n    }\n    // Update the internal tag state based on the buffer contents\n    _processBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n            xor_1.xor(this._buffer.data, this._offset.data);\n            this._counter++;\n            yield this._cipher.encryptBlock(this._buffer);\n            xor_1.xor(this._tag.data, this._buffer.data);\n            this._bufferPos = 0;\n        });\n    }\n}\nexports.PMAC = PMAC;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvbWFjL3BtYWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHFGQUFvQjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyxxR0FBNEI7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLGlGQUFrQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvbWFjL3BtYWMuanM/Mzc2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IFRvbnkgQXJjaWVyaSwgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJsb2NrXzEgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWxzL2Jsb2NrXCIpO1xuY29uc3QgY29uc3RhbnRfdGltZV8xID0gcmVxdWlyZShcIi4uL2ludGVybmFscy9jb25zdGFudC10aW1lXCIpO1xuY29uc3QgY3R6XzEgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWxzL2N0elwiKTtcbmNvbnN0IHhvcl8xID0gcmVxdWlyZShcIi4uL2ludGVybmFscy94b3JcIik7XG4vLyBOdW1iZXIgb2YgTCBibG9ja3MgdG8gcHJlY29tcHV0ZSAoaS5lLiDCtSBpbiB0aGUgUE1BQyBwYXBlcilcbi8vIFRPRE86IGR5bmFtaWNhbGx5IGNvbXB1dGUgdGhlc2UgYXMgbmVlZGVkXG5jb25zdCBQUkVDT01QVVRFRF9CTE9DS1MgPSAzMTtcbi8qKlxuICogUG9seWZpbGwgZm9yIHRoZSBBRVMtUE1BQyBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGVcbiAqXG4gKiBVc2VzIGEgbm9uLWNvbnN0YW50LXRpbWUgKGxvb2t1cCB0YWJsZS1iYXNlZCkgQUVTIHBvbHlmaWxsLlxuICogU2VlIHBvbHlmaWxsL2Flcy50cyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgc2VjdXJpdHkgaW1wYWN0LlxuICovXG5jbGFzcyBQTUFDIHtcbiAgICBjb25zdHJ1Y3RvcihjaXBoZXIsIGwsIGxJbnYpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbmlzaGVkIGlzIHNldCB0cnVlIHdoZW4gd2UgYXJlIGRvbmUgcHJvY2Vzc2luZyBhIG1lc3NhZ2UsIGFuZCBmb3JiaWRzXG4gICAgICAgICAqIGFueSBzdWJzZXF1ZW50IHdyaXRlcyB1bnRpbCB3ZSByZXNldCB0aGUgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcbiAgICAgICAgdGhpcy5fTCA9IGw7XG4gICAgICAgIHRoaXMuX0xJbnYgPSBsSW52O1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgYmxvY2tfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlclBvcyA9IDA7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBuZXcgYmxvY2tfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX3RhZyA9IG5ldyBibG9ja18xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBDTUFDIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGtleSAqL1xuICAgIHN0YXRpYyBpbXBvcnRLZXkocHJvdmlkZXIsIGtleURhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlciA9IHlpZWxkIHByb3ZpZGVyLmltcG9ydEJsb2NrQ2lwaGVyS2V5KGtleURhdGEpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMIGlzIGRlZmluZWQgYXMgZm9sbG93cyAocXVvdGVkIGZyb20gdGhlIFBNQUMgcGFwZXIpOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEVxdWF0aW9uIDE6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIGEgwrcgeCA9XG4gICAgICAgICAgICAgKiAgICAgICAgIGE8PDEgaWYgZmlyc3RiaXQoYSk9MFxuICAgICAgICAgICAgICogICAgICAgICAoYTw8MSkg4oqVIDDCucKy4oGwMTAwMDAxMTEgaWYgZmlyc3RiaXQoYSk9MVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEVxdWF0aW9uIDI6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIGEgwrcgeOKBu8K5ID1cbiAgICAgICAgICAgICAqICAgICAgICAgYT4+MSBpZiBsYXN0Yml0KGEpPTBcbiAgICAgICAgICAgICAqICAgICAgICAgKGE+PjEpIOKKlSAxMMK5wrLigbAxMDAwMDExIGlmIGxhc3RiaXQoYSk9MVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIExldCBMKDApIOKGkCBMLiBGb3IgaSDiiIggWzEuLsK1XSwgY29tcHV0ZSBMKGkpIOKGkCBMKGkg4oiSIDEpIMK3IHggYnlcbiAgICAgICAgICAgICAqIEVxdWF0aW9uICgxKSB1c2luZyBhIHNoaWZ0IGFuZCBhIGNvbmRpdGlvbmFsIHhvci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBDb21wdXRlIEwo4oiSMSkg4oaQIEwgwrcgeOKBu8K5IGJ5IEVxdWF0aW9uICgyKSwgdXNpbmcgYSBzaGlmdCBhbmQgYVxuICAgICAgICAgICAgICogY29uZGl0aW9uYWwgeG9yLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNhdmUgdGhlIHZhbHVlcyBMKOKIkjEpLCBMKDApLCBMKDEpLCBMKDIpLCAuLi4sIEwowrUpIGluIGEgdGFibGUuXG4gICAgICAgICAgICAgKiAoQWx0ZXJuYXRpdmVseSwgW2VkOiBhcyB3ZSBoYXZlIGRvbmUgaW4gdGhpcyBjb2RlYmFzZV0gZGVmZXIgY29tcHV0aW5nXG4gICAgICAgICAgICAgKiBzb21lIG9yICBhbGwgb2YgdGhlc2UgTChpKSB2YWx1ZXMgdW50aWwgdGhlIHZhbHVlIGlzIGFjdHVhbGx5IG5lZWRlZC4pXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBibG9ja18xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHlpZWxkIGNpcGhlci5lbmNyeXB0QmxvY2sodG1wKTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuZXcgQXJyYXkoUFJFQ09NUFVURURfQkxPQ0tTKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJFQ09NUFVURURfQkxPQ0tTOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsW2ldID0gdG1wLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdG1wLmRibCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb21wdXRlIEwo4oiSMSkg4oaQIEwgwrcgeOKBu8K5OlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICBhPj4xIGlmIGxhc3RiaXQoYSk9MFxuICAgICAgICAgICAgICogICAgIChhPj4xKSDiipUgMTDCucKy4oGwMTAwMDAxMSBpZiBsYXN0Yml0KGEpPTFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgbEludiA9IGxbMF0uY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCaXQgPSBsSW52LmRhdGFbYmxvY2tfMS5kZWZhdWx0LlNJWkUgLSAxXSAmIDB4MDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYmxvY2tfMS5kZWZhdWx0LlNJWkUgLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FycnkgPSBjb25zdGFudF90aW1lXzEuc2VsZWN0KGxJbnYuZGF0YVtpIC0gMV0gJiAxLCAweDgwLCAwKTtcbiAgICAgICAgICAgICAgICBsSW52LmRhdGFbaV0gPSAobEludi5kYXRhW2ldID4+PiAxKSB8IGNhcnJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbEludi5kYXRhWzBdID4+Pj0gMTtcbiAgICAgICAgICAgIGxJbnYuZGF0YVswXSBePSBjb25zdGFudF90aW1lXzEuc2VsZWN0KGxhc3RCaXQsIDB4ODAsIDApO1xuICAgICAgICAgICAgbEludi5kYXRhW2Jsb2NrXzEuZGVmYXVsdC5TSVpFIC0gMV0gXj0gY29uc3RhbnRfdGltZV8xLnNlbGVjdChsYXN0Qml0LCBibG9ja18xLmRlZmF1bHQuUiA+Pj4gMSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBNQUMoY2lwaGVyLCBsLCBsSW52KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9idWZmZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX29mZnNldC5jbGVhcigpO1xuICAgICAgICB0aGlzLl90YWcuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2NpcGhlci5jbGVhcigpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG1hYzogYWxyZWFkeSBmaW5pc2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBibG9ja18xLmRlZmF1bHQuU0laRSAtIHRoaXMuX2J1ZmZlclBvcztcbiAgICAgICAgICAgIGxldCBkYXRhUG9zID0gMDtcbiAgICAgICAgICAgIGxldCBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAvLyBGaW5pc2ggZmlsbGluZyB0aGUgaW50ZXJuYWwgYnVmIHdpdGggdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoID4gbGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5kYXRhLnNldChkYXRhLnNsaWNlKDAsIGxlZnQpLCB0aGlzLl9idWZmZXJQb3MpO1xuICAgICAgICAgICAgICAgIGRhdGFQb3MgKz0gbGVmdDtcbiAgICAgICAgICAgICAgICBkYXRhTGVuZ3RoIC09IGxlZnQ7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU28gbG9uZyBhcyB3ZSBoYXZlIG1vcmUgdGhhbiBhIGJsb2NrcyB3b3J0aCBvZiBkYXRhLCBjb21wdXRlXG4gICAgICAgICAgICAvLyB3aG9sZS1zaXplZCBibG9ja3MgYXQgYSB0aW1lLlxuICAgICAgICAgICAgd2hpbGUgKGRhdGFMZW5ndGggPiBibG9ja18xLmRlZmF1bHQuU0laRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5kYXRhLnNldChkYXRhLnNsaWNlKGRhdGFQb3MsIGRhdGFQb3MgKyBibG9ja18xLmRlZmF1bHQuU0laRSkpO1xuICAgICAgICAgICAgICAgIGRhdGFQb3MgKz0gYmxvY2tfMS5kZWZhdWx0LlNJWkU7XG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aCAtPSBibG9ja18xLmRlZmF1bHQuU0laRTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9wcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIuZGF0YS5zZXQoZGF0YS5zbGljZShkYXRhUG9zLCBkYXRhUG9zICsgZGF0YUxlbmd0aCksIHRoaXMuX2J1ZmZlclBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyUG9zICs9IGRhdGFMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBtYWM6IGFscmVhZHkgZmluaXNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVyUG9zID09PSBibG9ja18xLmRlZmF1bHQuU0laRSkge1xuICAgICAgICAgICAgICAgIHhvcl8xLnhvcih0aGlzLl90YWcuZGF0YSwgdGhpcy5fYnVmZmVyLmRhdGEpO1xuICAgICAgICAgICAgICAgIHhvcl8xLnhvcih0aGlzLl90YWcuZGF0YSwgdGhpcy5fTEludi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHhvcl8xLnhvcih0aGlzLl90YWcuZGF0YSwgdGhpcy5fYnVmZmVyLmRhdGEuc2xpY2UoMCwgdGhpcy5fYnVmZmVyUG9zKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFnLmRhdGFbdGhpcy5fYnVmZmVyUG9zXSBePSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl90YWcpO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhZy5jbG9uZSgpLmRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIHRhZyBzdGF0ZSBiYXNlZCBvbiB0aGUgYnVmZmVyIGNvbnRlbnRzXG4gICAgX3Byb2Nlc3NCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB4b3JfMS54b3IodGhpcy5fb2Zmc2V0LmRhdGEsIHRoaXMuX0xbY3R6XzEuY3R6KHRoaXMuX2NvdW50ZXIgKyAxKV0uZGF0YSk7XG4gICAgICAgICAgICB4b3JfMS54b3IodGhpcy5fYnVmZmVyLmRhdGEsIHRoaXMuX29mZnNldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodGhpcy5fYnVmZmVyKTtcbiAgICAgICAgICAgIHhvcl8xLnhvcih0aGlzLl90YWcuZGF0YSwgdGhpcy5fYnVmZmVyLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyUG9zID0gMDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QTUFDID0gUE1BQztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/mac/pmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/providers/polyfill.js":
/*!**************************************************************!*\
  !*** ./node_modules/miscreant/release/providers/polyfill.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst aes_1 = __webpack_require__(/*! ./polyfill/aes */ \"(rsc)/./node_modules/miscreant/release/providers/polyfill/aes.js\");\nconst aes_ctr_1 = __webpack_require__(/*! ./polyfill/aes_ctr */ \"(rsc)/./node_modules/miscreant/release/providers/polyfill/aes_ctr.js\");\n/**\n * Pure JavaScript cryptography implementations\n *\n * WARNING: Not constant time! May leak keys or have other security issues.\n */\nclass PolyfillCryptoProvider {\n    constructor() {\n        // This class doesn't do anything, it just signals that polyfill impls should be used\n    }\n    importBlockCipherKey(keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new aes_1.default(keyData);\n        });\n    }\n    importCTRKey(keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new aes_ctr_1.default(new aes_1.default(keyData));\n        });\n    }\n}\nexports.PolyfillCryptoProvider = PolyfillCryptoProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3BvbHlmaWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyx3RkFBZ0I7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsZ0dBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3BvbHlmaWxsLmpzP2Y5NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFlc18xID0gcmVxdWlyZShcIi4vcG9seWZpbGwvYWVzXCIpO1xuY29uc3QgYWVzX2N0cl8xID0gcmVxdWlyZShcIi4vcG9seWZpbGwvYWVzX2N0clwiKTtcbi8qKlxuICogUHVyZSBKYXZhU2NyaXB0IGNyeXB0b2dyYXBoeSBpbXBsZW1lbnRhdGlvbnNcbiAqXG4gKiBXQVJOSU5HOiBOb3QgY29uc3RhbnQgdGltZSEgTWF5IGxlYWsga2V5cyBvciBoYXZlIG90aGVyIHNlY3VyaXR5IGlzc3Vlcy5cbiAqL1xuY2xhc3MgUG9seWZpbGxDcnlwdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFRoaXMgY2xhc3MgZG9lc24ndCBkbyBhbnl0aGluZywgaXQganVzdCBzaWduYWxzIHRoYXQgcG9seWZpbGwgaW1wbHMgc2hvdWxkIGJlIHVzZWRcbiAgICB9XG4gICAgaW1wb3J0QmxvY2tDaXBoZXJLZXkoa2V5RGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhZXNfMS5kZWZhdWx0KGtleURhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wb3J0Q1RSS2V5KGtleURhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYWVzX2N0cl8xLmRlZmF1bHQobmV3IGFlc18xLmRlZmF1bHQoa2V5RGF0YSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBvbHlmaWxsQ3J5cHRvUHJvdmlkZXIgPSBQb2x5ZmlsbENyeXB0b1Byb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/providers/polyfill.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/providers/polyfill/aes.js":
/*!******************************************************************!*\
  !*** ./node_modules/miscreant/release/providers/polyfill/aes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst wipe_1 = __webpack_require__(/*! ../../internals/wipe */ \"(rsc)/./node_modules/miscreant/release/internals/wipe.js\");\n// Powers of x mod poly in GF(2).\nconst POWX = new Uint8Array([\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,\n    0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,\n]);\n// FIPS-197 Figure 7. S-box substitution values in hexadecimal format.\nconst SBOX0 = new Uint8Array([\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]);\n// FIPS-197 Figure 14.  Inverse S-box substitution values in hexadecimal format.\nconst SBOX1 = new Uint8Array([\n    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,\n]);\n// Encryption and decryption tables.\n// Will be computed by initialize() when the first AES instance is created.\nlet isInitialized = false;\nlet Te0;\nlet Te1;\nlet Te2;\nlet Te3;\nlet Td0;\nlet Td1;\nlet Td2;\nlet Td3;\n/**\n * Polyfill for the AES block cipher.\n *\n * This implementation uses lookup tables, so it's susceptible to cache-timing\n * side-channel attacks. A constant-time version we tried was super slow (a few\n * kilobytes per second), so we'll have to live with it.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\nclass PolyfillAes {\n    /**\n     * Constructs AES with the given 16 or 32-byte key\n     * for AES-128 or AES-256.\n     */\n    constructor(keyData) {\n        if (!isInitialized) {\n            initialize();\n        }\n        // Only AES-128 and AES-256 supported. AES-192 is not.\n        if (keyData.length !== 16 && keyData.length !== 32) {\n            throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n        }\n        this._encKey = expandKey(keyData);\n        this._emptyPromise = Promise.resolve(this);\n    }\n    /**\n     * Cleans expanded keys from memory, setting them to zeros.\n     */\n    clear() {\n        if (this._encKey) {\n            wipe_1.wipe(this._encKey);\n        }\n        return this;\n    }\n    /**\n     * Encrypt 16-byte block in-place, replacing its contents with ciphertext.\n     *\n     * This function should not be used to encrypt data without any\n     * cipher mode! It should only be used to implement a cipher mode.\n     * This library uses it to implement AES-SIV.\n     */\n    encryptBlock(block) {\n        const src = block.data;\n        const dst = block.data;\n        let s0 = readUint32BE(src, 0);\n        let s1 = readUint32BE(src, 4);\n        let s2 = readUint32BE(src, 8);\n        let s3 = readUint32BE(src, 12);\n        // First round just XORs input with key.\n        s0 ^= this._encKey[0];\n        s1 ^= this._encKey[1];\n        s2 ^= this._encKey[2];\n        s3 ^= this._encKey[3];\n        let t0 = 0;\n        let t1 = 0;\n        let t2 = 0;\n        let t3 = 0;\n        // Middle rounds shuffle using tables.\n        // Number of rounds is set by length of expanded key.\n        const nr = this._encKey.length / 4 - 2; // - 2: one above, one more below\n        let k = 4;\n        for (let r = 0; r < nr; r++) {\n            t0 = this._encKey[k + 0] ^ Te0[(s0 >>> 24) & 0xff] ^ Te1[(s1 >>> 16) & 0xff] ^\n                Te2[(s2 >>> 8) & 0xff] ^ Te3[s3 & 0xff];\n            t1 = this._encKey[k + 1] ^ Te0[(s1 >>> 24) & 0xff] ^ Te1[(s2 >>> 16) & 0xff] ^\n                Te2[(s3 >>> 8) & 0xff] ^ Te3[s0 & 0xff];\n            t2 = this._encKey[k + 2] ^ Te0[(s2 >>> 24) & 0xff] ^ Te1[(s3 >>> 16) & 0xff] ^\n                Te2[(s0 >>> 8) & 0xff] ^ Te3[s1 & 0xff];\n            t3 = this._encKey[k + 3] ^ Te0[(s3 >>> 24) & 0xff] ^ Te1[(s0 >>> 16) & 0xff] ^\n                Te2[(s1 >>> 8) & 0xff] ^ Te3[s2 & 0xff];\n            k += 4;\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n        }\n        // Last round uses s-box directly and XORs to produce output.\n        s0 = (SBOX0[t0 >>> 24] << 24) | (SBOX0[(t1 >>> 16) & 0xff]) << 16 |\n            (SBOX0[(t2 >>> 8) & 0xff]) << 8 | (SBOX0[t3 & 0xff]);\n        s1 = (SBOX0[t1 >>> 24] << 24) | (SBOX0[(t2 >>> 16) & 0xff]) << 16 |\n            (SBOX0[(t3 >>> 8) & 0xff]) << 8 | (SBOX0[t0 & 0xff]);\n        s2 = (SBOX0[t2 >>> 24] << 24) | (SBOX0[(t3 >>> 16) & 0xff]) << 16 |\n            (SBOX0[(t0 >>> 8) & 0xff]) << 8 | (SBOX0[t1 & 0xff]);\n        s3 = (SBOX0[t3 >>> 24] << 24) | (SBOX0[(t0 >>> 16) & 0xff]) << 16 |\n            (SBOX0[(t1 >>> 8) & 0xff]) << 8 | (SBOX0[t2 & 0xff]);\n        s0 ^= this._encKey[k + 0];\n        s1 ^= this._encKey[k + 1];\n        s2 ^= this._encKey[k + 2];\n        s3 ^= this._encKey[k + 3];\n        writeUint32BE(s0, dst, 0);\n        writeUint32BE(s1, dst, 4);\n        writeUint32BE(s2, dst, 8);\n        writeUint32BE(s3, dst, 12);\n        return this._emptyPromise;\n    }\n}\nexports[\"default\"] = PolyfillAes;\n// Initialize generates encryption and decryption tables.\nfunction initialize() {\n    const poly = (1 << 8) | (1 << 4) | (1 << 3) | (1 << 1) | (1 << 0);\n    function mul(b, c) {\n        let i = b;\n        let j = c;\n        let s = 0;\n        for (let k = 1; k < 0x100 && j !== 0; k <<= 1) {\n            // Invariant: k == 1<<n, i == b * x^n\n            if ((j & k) !== 0) {\n                // s += i in GF(2); xor in binary\n                s ^= i;\n                j ^= k; // turn off bit to end loop early\n            }\n            // i *= x in GF(2) modulo the polynomial\n            i <<= 1;\n            if ((i & 0x100) !== 0) {\n                i ^= poly;\n            }\n        }\n        return s;\n    }\n    const rot = (x) => (x << 24) | (x >>> 8);\n    // Generate encryption tables.\n    Te0 = new Uint32Array(256);\n    Te1 = new Uint32Array(256);\n    Te2 = new Uint32Array(256);\n    Te3 = new Uint32Array(256);\n    for (let i = 0; i < 256; i++) {\n        const s = SBOX0[i];\n        let w = (mul(s, 2) << 24) | (s << 16) | (s << 8) | mul(s, 3);\n        Te0[i] = w;\n        w = rot(w);\n        Te1[i] = w;\n        w = rot(w);\n        Te2[i] = w;\n        w = rot(w);\n        Te3[i] = w;\n        w = rot(w);\n    }\n    // Generate decryption tables.\n    Td0 = new Uint32Array(256);\n    Td1 = new Uint32Array(256);\n    Td2 = new Uint32Array(256);\n    Td3 = new Uint32Array(256);\n    for (let i = 0; i < 256; i++) {\n        const s = SBOX1[i];\n        let w = (mul(s, 0xe) << 24) | (mul(s, 0x9) << 16) |\n            (mul(s, 0xd) << 8) | mul(s, 0xb);\n        Td0[i] = w;\n        w = rot(w);\n        Td1[i] = w;\n        w = rot(w);\n        Td2[i] = w;\n        w = rot(w);\n        Td3[i] = w;\n        w = rot(w);\n    }\n    isInitialized = true;\n}\n// Reads 4 bytes from array starting at offset as big-endian\n// unsigned 32-bit integer and returns it.\nfunction readUint32BE(array, offset = 0) {\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\n// Writes 4-byte big-endian representation of 32-bit unsigned\n// value to byte array starting at offset.\n//\n// If byte array is not given, creates a new 4-byte one.\n//\n// Returns the output byte array.\nfunction writeUint32BE(value, out = new Uint8Array(4), offset = 0) {\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\n// Apply sbox0 to each byte in w.\nfunction subw(w) {\n    return ((SBOX0[(w >>> 24) & 0xff]) << 24) |\n        ((SBOX0[(w >>> 16) & 0xff]) << 16) |\n        ((SBOX0[(w >>> 8) & 0xff]) << 8) |\n        (SBOX0[w & 0xff]);\n}\n// Rotate\nfunction rotw(w) {\n    return (w << 8) | (w >>> 24);\n}\nfunction expandKey(key) {\n    const encKey = new Uint32Array(key.length + 28);\n    const nk = key.length / 4 | 0;\n    const n = encKey.length;\n    for (let i = 0; i < nk; i++) {\n        encKey[i] = readUint32BE(key, i * 4);\n    }\n    for (let i = nk; i < n; i++) {\n        let t = encKey[i - 1];\n        if (i % nk === 0) {\n            t = subw(rotw(t)) ^ (POWX[i / nk - 1] << 24);\n        }\n        else if (nk > 6 && i % nk === 4) {\n            t = subw(t);\n        }\n        encKey[i] = encKey[i - nk] ^ t;\n    }\n    return encKey;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3BvbHlmaWxsL2Flcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLHNGQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3BvbHlmaWxsL2Flcy5qcz80Y2U2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgRG1pdHJ5IENoZXN0bnlraCwgVG9ueSBBcmNpZXJpXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHdpcGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcm5hbHMvd2lwZVwiKTtcbi8vIFBvd2VycyBvZiB4IG1vZCBwb2x5IGluIEdGKDIpLlxuY29uc3QgUE9XWCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLFxuICAgIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsXG5dKTtcbi8vIEZJUFMtMTk3IEZpZ3VyZSA3LiBTLWJveCBzdWJzdGl0dXRpb24gdmFsdWVzIGluIGhleGFkZWNpbWFsIGZvcm1hdC5cbmNvbnN0IFNCT1gwID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4NjMsIDB4N2MsIDB4NzcsIDB4N2IsIDB4ZjIsIDB4NmIsIDB4NmYsIDB4YzUsIDB4MzAsIDB4MDEsIDB4NjcsIDB4MmIsIDB4ZmUsIDB4ZDcsIDB4YWIsIDB4NzYsXG4gICAgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCxcbiAgICAweGI3LCAweGZkLCAweDkzLCAweDI2LCAweDM2LCAweDNmLCAweGY3LCAweGNjLCAweDM0LCAweGE1LCAweGU1LCAweGYxLCAweDcxLCAweGQ4LCAweDMxLCAweDE1LFxuICAgIDB4MDQsIDB4YzcsIDB4MjMsIDB4YzMsIDB4MTgsIDB4OTYsIDB4MDUsIDB4OWEsIDB4MDcsIDB4MTIsIDB4ODAsIDB4ZTIsIDB4ZWIsIDB4MjcsIDB4YjIsIDB4NzUsXG4gICAgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCxcbiAgICAweDUzLCAweGQxLCAweDAwLCAweGVkLCAweDIwLCAweGZjLCAweGIxLCAweDViLCAweDZhLCAweGNiLCAweGJlLCAweDM5LCAweDRhLCAweDRjLCAweDU4LCAweGNmLFxuICAgIDB4ZDAsIDB4ZWYsIDB4YWEsIDB4ZmIsIDB4NDMsIDB4NGQsIDB4MzMsIDB4ODUsIDB4NDUsIDB4ZjksIDB4MDIsIDB4N2YsIDB4NTAsIDB4M2MsIDB4OWYsIDB4YTgsXG4gICAgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMixcbiAgICAweGNkLCAweDBjLCAweDEzLCAweGVjLCAweDVmLCAweDk3LCAweDQ0LCAweDE3LCAweGM0LCAweGE3LCAweDdlLCAweDNkLCAweDY0LCAweDVkLCAweDE5LCAweDczLFxuICAgIDB4NjAsIDB4ODEsIDB4NGYsIDB4ZGMsIDB4MjIsIDB4MmEsIDB4OTAsIDB4ODgsIDB4NDYsIDB4ZWUsIDB4YjgsIDB4MTQsIDB4ZGUsIDB4NWUsIDB4MGIsIDB4ZGIsXG4gICAgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSxcbiAgICAweGU3LCAweGM4LCAweDM3LCAweDZkLCAweDhkLCAweGQ1LCAweDRlLCAweGE5LCAweDZjLCAweDU2LCAweGY0LCAweGVhLCAweDY1LCAweDdhLCAweGFlLCAweDA4LFxuICAgIDB4YmEsIDB4NzgsIDB4MjUsIDB4MmUsIDB4MWMsIDB4YTYsIDB4YjQsIDB4YzYsIDB4ZTgsIDB4ZGQsIDB4NzQsIDB4MWYsIDB4NGIsIDB4YmQsIDB4OGIsIDB4OGEsXG4gICAgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSxcbiAgICAweGUxLCAweGY4LCAweDk4LCAweDExLCAweDY5LCAweGQ5LCAweDhlLCAweDk0LCAweDliLCAweDFlLCAweDg3LCAweGU5LCAweGNlLCAweDU1LCAweDI4LCAweGRmLFxuICAgIDB4OGMsIDB4YTEsIDB4ODksIDB4MGQsIDB4YmYsIDB4ZTYsIDB4NDIsIDB4NjgsIDB4NDEsIDB4OTksIDB4MmQsIDB4MGYsIDB4YjAsIDB4NTQsIDB4YmIsIDB4MTYsXG5dKTtcbi8vIEZJUFMtMTk3IEZpZ3VyZSAxNC4gIEludmVyc2UgUy1ib3ggc3Vic3RpdHV0aW9uIHZhbHVlcyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG5jb25zdCBTQk9YMSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLFxuICAgIDB4N2MsIDB4ZTMsIDB4MzksIDB4ODIsIDB4OWIsIDB4MmYsIDB4ZmYsIDB4ODcsIDB4MzQsIDB4OGUsIDB4NDMsIDB4NDQsIDB4YzQsIDB4ZGUsIDB4ZTksIDB4Y2IsXG4gICAgMHg1NCwgMHg3YiwgMHg5NCwgMHgzMiwgMHhhNiwgMHhjMiwgMHgyMywgMHgzZCwgMHhlZSwgMHg0YywgMHg5NSwgMHgwYiwgMHg0MiwgMHhmYSwgMHhjMywgMHg0ZSxcbiAgICAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LFxuICAgIDB4NzIsIDB4ZjgsIDB4ZjYsIDB4NjQsIDB4ODYsIDB4NjgsIDB4OTgsIDB4MTYsIDB4ZDQsIDB4YTQsIDB4NWMsIDB4Y2MsIDB4NWQsIDB4NjUsIDB4YjYsIDB4OTIsXG4gICAgMHg2YywgMHg3MCwgMHg0OCwgMHg1MCwgMHhmZCwgMHhlZCwgMHhiOSwgMHhkYSwgMHg1ZSwgMHgxNSwgMHg0NiwgMHg1NywgMHhhNywgMHg4ZCwgMHg5ZCwgMHg4NCxcbiAgICAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LFxuICAgIDB4ZDAsIDB4MmMsIDB4MWUsIDB4OGYsIDB4Y2EsIDB4M2YsIDB4MGYsIDB4MDIsIDB4YzEsIDB4YWYsIDB4YmQsIDB4MDMsIDB4MDEsIDB4MTMsIDB4OGEsIDB4NmIsXG4gICAgMHgzYSwgMHg5MSwgMHgxMSwgMHg0MSwgMHg0ZiwgMHg2NywgMHhkYywgMHhlYSwgMHg5NywgMHhmMiwgMHhjZiwgMHhjZSwgMHhmMCwgMHhiNCwgMHhlNiwgMHg3MyxcbiAgICAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLFxuICAgIDB4NDcsIDB4ZjEsIDB4MWEsIDB4NzEsIDB4MWQsIDB4MjksIDB4YzUsIDB4ODksIDB4NmYsIDB4YjcsIDB4NjIsIDB4MGUsIDB4YWEsIDB4MTgsIDB4YmUsIDB4MWIsXG4gICAgMHhmYywgMHg1NiwgMHgzZSwgMHg0YiwgMHhjNiwgMHhkMiwgMHg3OSwgMHgyMCwgMHg5YSwgMHhkYiwgMHhjMCwgMHhmZSwgMHg3OCwgMHhjZCwgMHg1YSwgMHhmNCxcbiAgICAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLFxuICAgIDB4NjAsIDB4NTEsIDB4N2YsIDB4YTksIDB4MTksIDB4YjUsIDB4NGEsIDB4MGQsIDB4MmQsIDB4ZTUsIDB4N2EsIDB4OWYsIDB4OTMsIDB4YzksIDB4OWMsIDB4ZWYsXG4gICAgMHhhMCwgMHhlMCwgMHgzYiwgMHg0ZCwgMHhhZSwgMHgyYSwgMHhmNSwgMHhiMCwgMHhjOCwgMHhlYiwgMHhiYiwgMHgzYywgMHg4MywgMHg1MywgMHg5OSwgMHg2MSxcbiAgICAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkLFxuXSk7XG4vLyBFbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uIHRhYmxlcy5cbi8vIFdpbGwgYmUgY29tcHV0ZWQgYnkgaW5pdGlhbGl6ZSgpIHdoZW4gdGhlIGZpcnN0IEFFUyBpbnN0YW5jZSBpcyBjcmVhdGVkLlxubGV0IGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBUZTA7XG5sZXQgVGUxO1xubGV0IFRlMjtcbmxldCBUZTM7XG5sZXQgVGQwO1xubGV0IFRkMTtcbmxldCBUZDI7XG5sZXQgVGQzO1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgdGhlIEFFUyBibG9jayBjaXBoZXIuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIGxvb2t1cCB0YWJsZXMsIHNvIGl0J3Mgc3VzY2VwdGlibGUgdG8gY2FjaGUtdGltaW5nXG4gKiBzaWRlLWNoYW5uZWwgYXR0YWNrcy4gQSBjb25zdGFudC10aW1lIHZlcnNpb24gd2UgdHJpZWQgd2FzIHN1cGVyIHNsb3cgKGEgZmV3XG4gKiBraWxvYnl0ZXMgcGVyIHNlY29uZCksIHNvIHdlJ2xsIGhhdmUgdG8gbGl2ZSB3aXRoIGl0LlxuICpcbiAqIEtleSBzaXplOiAxNiBvciAzMiBieXRlcywgYmxvY2sgc2l6ZTogMTYgYnl0ZXMuXG4gKi9cbmNsYXNzIFBvbHlmaWxsQWVzIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIEFFUyB3aXRoIHRoZSBnaXZlbiAxNiBvciAzMi1ieXRlIGtleVxuICAgICAqIGZvciBBRVMtMTI4IG9yIEFFUy0yNTYuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5RGF0YSkge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IEFFUy0xMjggYW5kIEFFUy0yNTYgc3VwcG9ydGVkLiBBRVMtMTkyIGlzIG5vdC5cbiAgICAgICAgaWYgKGtleURhdGEubGVuZ3RoICE9PSAxNiAmJiBrZXlEYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzY3JlYW50OiBpbnZhbGlkIGtleSBsZW5ndGg6ICR7a2V5RGF0YS5sZW5ndGh9IChleHBlY3RlZCAxNiBvciAzMiBieXRlcylgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmNLZXkgPSBleHBhbmRLZXkoa2V5RGF0YSk7XG4gICAgICAgIHRoaXMuX2VtcHR5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIGV4cGFuZGVkIGtleXMgZnJvbSBtZW1vcnksIHNldHRpbmcgdGhlbSB0byB6ZXJvcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuY0tleSkge1xuICAgICAgICAgICAgd2lwZV8xLndpcGUodGhpcy5fZW5jS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCAxNi1ieXRlIGJsb2NrIGluLXBsYWNlLCByZXBsYWNpbmcgaXRzIGNvbnRlbnRzIHdpdGggY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSB1c2VkIHRvIGVuY3J5cHQgZGF0YSB3aXRob3V0IGFueVxuICAgICAqIGNpcGhlciBtb2RlISBJdCBzaG91bGQgb25seSBiZSB1c2VkIHRvIGltcGxlbWVudCBhIGNpcGhlciBtb2RlLlxuICAgICAqIFRoaXMgbGlicmFyeSB1c2VzIGl0IHRvIGltcGxlbWVudCBBRVMtU0lWLlxuICAgICAqL1xuICAgIGVuY3J5cHRCbG9jayhibG9jaykge1xuICAgICAgICBjb25zdCBzcmMgPSBibG9jay5kYXRhO1xuICAgICAgICBjb25zdCBkc3QgPSBibG9jay5kYXRhO1xuICAgICAgICBsZXQgczAgPSByZWFkVWludDMyQkUoc3JjLCAwKTtcbiAgICAgICAgbGV0IHMxID0gcmVhZFVpbnQzMkJFKHNyYywgNCk7XG4gICAgICAgIGxldCBzMiA9IHJlYWRVaW50MzJCRShzcmMsIDgpO1xuICAgICAgICBsZXQgczMgPSByZWFkVWludDMyQkUoc3JjLCAxMik7XG4gICAgICAgIC8vIEZpcnN0IHJvdW5kIGp1c3QgWE9ScyBpbnB1dCB3aXRoIGtleS5cbiAgICAgICAgczAgXj0gdGhpcy5fZW5jS2V5WzBdO1xuICAgICAgICBzMSBePSB0aGlzLl9lbmNLZXlbMV07XG4gICAgICAgIHMyIF49IHRoaXMuX2VuY0tleVsyXTtcbiAgICAgICAgczMgXj0gdGhpcy5fZW5jS2V5WzNdO1xuICAgICAgICBsZXQgdDAgPSAwO1xuICAgICAgICBsZXQgdDEgPSAwO1xuICAgICAgICBsZXQgdDIgPSAwO1xuICAgICAgICBsZXQgdDMgPSAwO1xuICAgICAgICAvLyBNaWRkbGUgcm91bmRzIHNodWZmbGUgdXNpbmcgdGFibGVzLlxuICAgICAgICAvLyBOdW1iZXIgb2Ygcm91bmRzIGlzIHNldCBieSBsZW5ndGggb2YgZXhwYW5kZWQga2V5LlxuICAgICAgICBjb25zdCBuciA9IHRoaXMuX2VuY0tleS5sZW5ndGggLyA0IC0gMjsgLy8gLSAyOiBvbmUgYWJvdmUsIG9uZSBtb3JlIGJlbG93XG4gICAgICAgIGxldCBrID0gNDtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBucjsgcisrKSB7XG4gICAgICAgICAgICB0MCA9IHRoaXMuX2VuY0tleVtrICsgMF0gXiBUZTBbKHMwID4+PiAyNCkgJiAweGZmXSBeIFRlMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICBUZTJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gVGUzW3MzICYgMHhmZl07XG4gICAgICAgICAgICB0MSA9IHRoaXMuX2VuY0tleVtrICsgMV0gXiBUZTBbKHMxID4+PiAyNCkgJiAweGZmXSBeIFRlMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICBUZTJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gVGUzW3MwICYgMHhmZl07XG4gICAgICAgICAgICB0MiA9IHRoaXMuX2VuY0tleVtrICsgMl0gXiBUZTBbKHMyID4+PiAyNCkgJiAweGZmXSBeIFRlMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICBUZTJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gVGUzW3MxICYgMHhmZl07XG4gICAgICAgICAgICB0MyA9IHRoaXMuX2VuY0tleVtrICsgM10gXiBUZTBbKHMzID4+PiAyNCkgJiAweGZmXSBeIFRlMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICBUZTJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gVGUzW3MyICYgMHhmZl07XG4gICAgICAgICAgICBrICs9IDQ7XG4gICAgICAgICAgICBzMCA9IHQwO1xuICAgICAgICAgICAgczEgPSB0MTtcbiAgICAgICAgICAgIHMyID0gdDI7XG4gICAgICAgICAgICBzMyA9IHQzO1xuICAgICAgICB9XG4gICAgICAgIC8vIExhc3Qgcm91bmQgdXNlcyBzLWJveCBkaXJlY3RseSBhbmQgWE9ScyB0byBwcm9kdWNlIG91dHB1dC5cbiAgICAgICAgczAgPSAoU0JPWDBbdDAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWDBbKHQxID4+PiAxNikgJiAweGZmXSkgPDwgMTYgfFxuICAgICAgICAgICAgKFNCT1gwWyh0MiA+Pj4gOCkgJiAweGZmXSkgPDwgOCB8IChTQk9YMFt0MyAmIDB4ZmZdKTtcbiAgICAgICAgczEgPSAoU0JPWDBbdDEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWDBbKHQyID4+PiAxNikgJiAweGZmXSkgPDwgMTYgfFxuICAgICAgICAgICAgKFNCT1gwWyh0MyA+Pj4gOCkgJiAweGZmXSkgPDwgOCB8IChTQk9YMFt0MCAmIDB4ZmZdKTtcbiAgICAgICAgczIgPSAoU0JPWDBbdDIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWDBbKHQzID4+PiAxNikgJiAweGZmXSkgPDwgMTYgfFxuICAgICAgICAgICAgKFNCT1gwWyh0MCA+Pj4gOCkgJiAweGZmXSkgPDwgOCB8IChTQk9YMFt0MSAmIDB4ZmZdKTtcbiAgICAgICAgczMgPSAoU0JPWDBbdDMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWDBbKHQwID4+PiAxNikgJiAweGZmXSkgPDwgMTYgfFxuICAgICAgICAgICAgKFNCT1gwWyh0MSA+Pj4gOCkgJiAweGZmXSkgPDwgOCB8IChTQk9YMFt0MiAmIDB4ZmZdKTtcbiAgICAgICAgczAgXj0gdGhpcy5fZW5jS2V5W2sgKyAwXTtcbiAgICAgICAgczEgXj0gdGhpcy5fZW5jS2V5W2sgKyAxXTtcbiAgICAgICAgczIgXj0gdGhpcy5fZW5jS2V5W2sgKyAyXTtcbiAgICAgICAgczMgXj0gdGhpcy5fZW5jS2V5W2sgKyAzXTtcbiAgICAgICAgd3JpdGVVaW50MzJCRShzMCwgZHN0LCAwKTtcbiAgICAgICAgd3JpdGVVaW50MzJCRShzMSwgZHN0LCA0KTtcbiAgICAgICAgd3JpdGVVaW50MzJCRShzMiwgZHN0LCA4KTtcbiAgICAgICAgd3JpdGVVaW50MzJCRShzMywgZHN0LCAxMik7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbXB0eVByb21pc2U7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9seWZpbGxBZXM7XG4vLyBJbml0aWFsaXplIGdlbmVyYXRlcyBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uIHRhYmxlcy5cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgcG9seSA9ICgxIDw8IDgpIHwgKDEgPDwgNCkgfCAoMSA8PCAzKSB8ICgxIDw8IDEpIHwgKDEgPDwgMCk7XG4gICAgZnVuY3Rpb24gbXVsKGIsIGMpIHtcbiAgICAgICAgbGV0IGkgPSBiO1xuICAgICAgICBsZXQgaiA9IGM7XG4gICAgICAgIGxldCBzID0gMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCAweDEwMCAmJiBqICE9PSAwOyBrIDw8PSAxKSB7XG4gICAgICAgICAgICAvLyBJbnZhcmlhbnQ6IGsgPT0gMTw8biwgaSA9PSBiICogeF5uXG4gICAgICAgICAgICBpZiAoKGogJiBrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHMgKz0gaSBpbiBHRigyKTsgeG9yIGluIGJpbmFyeVxuICAgICAgICAgICAgICAgIHMgXj0gaTtcbiAgICAgICAgICAgICAgICBqIF49IGs7IC8vIHR1cm4gb2ZmIGJpdCB0byBlbmQgbG9vcCBlYXJseVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaSAqPSB4IGluIEdGKDIpIG1vZHVsbyB0aGUgcG9seW5vbWlhbFxuICAgICAgICAgICAgaSA8PD0gMTtcbiAgICAgICAgICAgIGlmICgoaSAmIDB4MTAwKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGkgXj0gcG9seTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgY29uc3Qgcm90ID0gKHgpID0+ICh4IDw8IDI0KSB8ICh4ID4+PiA4KTtcbiAgICAvLyBHZW5lcmF0ZSBlbmNyeXB0aW9uIHRhYmxlcy5cbiAgICBUZTAgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBUZTEgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBUZTIgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBUZTMgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHMgPSBTQk9YMFtpXTtcbiAgICAgICAgbGV0IHcgPSAobXVsKHMsIDIpIDw8IDI0KSB8IChzIDw8IDE2KSB8IChzIDw8IDgpIHwgbXVsKHMsIDMpO1xuICAgICAgICBUZTBbaV0gPSB3O1xuICAgICAgICB3ID0gcm90KHcpO1xuICAgICAgICBUZTFbaV0gPSB3O1xuICAgICAgICB3ID0gcm90KHcpO1xuICAgICAgICBUZTJbaV0gPSB3O1xuICAgICAgICB3ID0gcm90KHcpO1xuICAgICAgICBUZTNbaV0gPSB3O1xuICAgICAgICB3ID0gcm90KHcpO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBkZWNyeXB0aW9uIHRhYmxlcy5cbiAgICBUZDAgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBUZDEgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBUZDIgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBUZDMgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHMgPSBTQk9YMVtpXTtcbiAgICAgICAgbGV0IHcgPSAobXVsKHMsIDB4ZSkgPDwgMjQpIHwgKG11bChzLCAweDkpIDw8IDE2KSB8XG4gICAgICAgICAgICAobXVsKHMsIDB4ZCkgPDwgOCkgfCBtdWwocywgMHhiKTtcbiAgICAgICAgVGQwW2ldID0gdztcbiAgICAgICAgdyA9IHJvdCh3KTtcbiAgICAgICAgVGQxW2ldID0gdztcbiAgICAgICAgdyA9IHJvdCh3KTtcbiAgICAgICAgVGQyW2ldID0gdztcbiAgICAgICAgdyA9IHJvdCh3KTtcbiAgICAgICAgVGQzW2ldID0gdztcbiAgICAgICAgdyA9IHJvdCh3KTtcbiAgICB9XG4gICAgaXNJbml0aWFsaXplZCA9IHRydWU7XG59XG4vLyBSZWFkcyA0IGJ5dGVzIGZyb20gYXJyYXkgc3RhcnRpbmcgYXQgb2Zmc2V0IGFzIGJpZy1lbmRpYW5cbi8vIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuZnVuY3Rpb24gcmVhZFVpbnQzMkJFKGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgcmV0dXJuICgoYXJyYXlbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAoYXJyYXlbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgKGFycmF5W29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10pID4+PiAwO1xufVxuLy8gV3JpdGVzIDQtYnl0ZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uIG9mIDMyLWJpdCB1bnNpZ25lZFxuLy8gdmFsdWUgdG8gYnl0ZSBhcnJheSBzdGFydGluZyBhdCBvZmZzZXQuXG4vL1xuLy8gSWYgYnl0ZSBhcnJheSBpcyBub3QgZ2l2ZW4sIGNyZWF0ZXMgYSBuZXcgNC1ieXRlIG9uZS5cbi8vXG4vLyBSZXR1cm5zIHRoZSBvdXRwdXQgYnl0ZSBhcnJheS5cbmZ1bmN0aW9uIHdyaXRlVWludDMyQkUodmFsdWUsIG91dCA9IG5ldyBVaW50OEFycmF5KDQpLCBvZmZzZXQgPSAwKSB7XG4gICAgb3V0W29mZnNldCArIDBdID0gdmFsdWUgPj4+IDI0O1xuICAgIG91dFtvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjtcbiAgICBvdXRbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODtcbiAgICBvdXRbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuLy8gQXBwbHkgc2JveDAgdG8gZWFjaCBieXRlIGluIHcuXG5mdW5jdGlvbiBzdWJ3KHcpIHtcbiAgICByZXR1cm4gKChTQk9YMFsodyA+Pj4gMjQpICYgMHhmZl0pIDw8IDI0KSB8XG4gICAgICAgICgoU0JPWDBbKHcgPj4+IDE2KSAmIDB4ZmZdKSA8PCAxNikgfFxuICAgICAgICAoKFNCT1gwWyh3ID4+PiA4KSAmIDB4ZmZdKSA8PCA4KSB8XG4gICAgICAgIChTQk9YMFt3ICYgMHhmZl0pO1xufVxuLy8gUm90YXRlXG5mdW5jdGlvbiByb3R3KHcpIHtcbiAgICByZXR1cm4gKHcgPDwgOCkgfCAodyA+Pj4gMjQpO1xufVxuZnVuY3Rpb24gZXhwYW5kS2V5KGtleSkge1xuICAgIGNvbnN0IGVuY0tleSA9IG5ldyBVaW50MzJBcnJheShrZXkubGVuZ3RoICsgMjgpO1xuICAgIGNvbnN0IG5rID0ga2V5Lmxlbmd0aCAvIDQgfCAwO1xuICAgIGNvbnN0IG4gPSBlbmNLZXkubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbms7IGkrKykge1xuICAgICAgICBlbmNLZXlbaV0gPSByZWFkVWludDMyQkUoa2V5LCBpICogNCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBuazsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgdCA9IGVuY0tleVtpIC0gMV07XG4gICAgICAgIGlmIChpICUgbmsgPT09IDApIHtcbiAgICAgICAgICAgIHQgPSBzdWJ3KHJvdHcodCkpIF4gKFBPV1hbaSAvIG5rIC0gMV0gPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5rID4gNiAmJiBpICUgbmsgPT09IDQpIHtcbiAgICAgICAgICAgIHQgPSBzdWJ3KHQpO1xuICAgICAgICB9XG4gICAgICAgIGVuY0tleVtpXSA9IGVuY0tleVtpIC0gbmtdIF4gdDtcbiAgICB9XG4gICAgcmV0dXJuIGVuY0tleTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/providers/polyfill/aes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/providers/polyfill/aes_ctr.js":
/*!**********************************************************************!*\
  !*** ./node_modules/miscreant/release/providers/polyfill/aes_ctr.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst block_1 = __webpack_require__(/*! ../../internals/block */ \"(rsc)/./node_modules/miscreant/release/internals/block.js\");\n/**\n * Polyfill for the AES-CTR (counter) mode of operation.\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n *\n * Note that CTR mode is malleable and generally should not be used without\n * authentication. Instead, use an authenticated encryption mode, like AES-SIV!\n */\nclass PolyfillAesCtr {\n    constructor(cipher) {\n        // Set cipher.\n        this._cipher = cipher;\n        // Allocate space for counter.\n        this._counter = new block_1.default();\n        // Allocate buffer for encrypted block.\n        this._buffer = new block_1.default();\n    }\n    clear() {\n        this._buffer.clear();\n        this._counter.clear();\n        this._cipher.clear();\n        return this;\n    }\n    encryptCtr(iv, plaintext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (iv.length !== block_1.default.SIZE) {\n                throw new Error(\"CTR: iv length must be equal to cipher block size\");\n            }\n            // Copy IV to counter, overwriting it.\n            this._counter.data.set(iv);\n            // Set buffer position to length of buffer\n            // so that the first cipher block is generated.\n            let bufferPos = block_1.default.SIZE;\n            const result = new Uint8Array(plaintext.length);\n            for (let i = 0; i < plaintext.length; i++) {\n                if (bufferPos === block_1.default.SIZE) {\n                    this._buffer.copy(this._counter);\n                    this._cipher.encryptBlock(this._buffer);\n                    bufferPos = 0;\n                    incrementCounter(this._counter);\n                }\n                result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];\n            }\n            return result;\n        });\n    }\n}\nexports[\"default\"] = PolyfillAesCtr;\n// Increment an AES-CTR mode counter, intentionally wrapping/overflowing\nfunction incrementCounter(counter) {\n    let carry = 1;\n    for (let i = block_1.default.SIZE - 1; i >= 0; i--) {\n        carry += (counter.data[i] & 0xff) | 0;\n        counter.data[i] = carry & 0xff;\n        carry >>>= 8;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3BvbHlmaWxsL2Flc19jdHIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHdGQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL3Byb3ZpZGVycy9wb2x5ZmlsbC9hZXNfY3RyLmpzP2FjNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJsb2NrXzEgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJuYWxzL2Jsb2NrXCIpO1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgdGhlIEFFUy1DVFIgKGNvdW50ZXIpIG1vZGUgb2Ygb3BlcmF0aW9uLlxuICpcbiAqIFVzZXMgYSBub24tY29uc3RhbnQtdGltZSAobG9va3VwIHRhYmxlLWJhc2VkKSBBRVMgcG9seWZpbGwuXG4gKiBTZWUgcG9seWZpbGwvYWVzLnRzIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBzZWN1cml0eSBpbXBhY3QuXG4gKlxuICogTm90ZSB0aGF0IENUUiBtb2RlIGlzIG1hbGxlYWJsZSBhbmQgZ2VuZXJhbGx5IHNob3VsZCBub3QgYmUgdXNlZCB3aXRob3V0XG4gKiBhdXRoZW50aWNhdGlvbi4gSW5zdGVhZCwgdXNlIGFuIGF1dGhlbnRpY2F0ZWQgZW5jcnlwdGlvbiBtb2RlLCBsaWtlIEFFUy1TSVYhXG4gKi9cbmNsYXNzIFBvbHlmaWxsQWVzQ3RyIHtcbiAgICBjb25zdHJ1Y3RvcihjaXBoZXIpIHtcbiAgICAgICAgLy8gU2V0IGNpcGhlci5cbiAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuICAgICAgICAvLyBBbGxvY2F0ZSBzcGFjZSBmb3IgY291bnRlci5cbiAgICAgICAgdGhpcy5fY291bnRlciA9IG5ldyBibG9ja18xLmRlZmF1bHQoKTtcbiAgICAgICAgLy8gQWxsb2NhdGUgYnVmZmVyIGZvciBlbmNyeXB0ZWQgYmxvY2suXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBibG9ja18xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlci5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb3VudGVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NpcGhlci5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW5jcnlwdEN0cihpdiwgcGxhaW50ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICE9PSBibG9ja18xLmRlZmF1bHQuU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNUUjogaXYgbGVuZ3RoIG11c3QgYmUgZXF1YWwgdG8gY2lwaGVyIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3B5IElWIHRvIGNvdW50ZXIsIG92ZXJ3cml0aW5nIGl0LlxuICAgICAgICAgICAgdGhpcy5fY291bnRlci5kYXRhLnNldChpdik7XG4gICAgICAgICAgICAvLyBTZXQgYnVmZmVyIHBvc2l0aW9uIHRvIGxlbmd0aCBvZiBidWZmZXJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGZpcnN0IGNpcGhlciBibG9jayBpcyBnZW5lcmF0ZWQuXG4gICAgICAgICAgICBsZXQgYnVmZmVyUG9zID0gYmxvY2tfMS5kZWZhdWx0LlNJWkU7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlclBvcyA9PT0gYmxvY2tfMS5kZWZhdWx0LlNJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLmNvcHkodGhpcy5fY291bnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodGhpcy5fYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50Q291bnRlcih0aGlzLl9jb3VudGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcGxhaW50ZXh0W2ldIF4gdGhpcy5fYnVmZmVyLmRhdGFbYnVmZmVyUG9zKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9seWZpbGxBZXNDdHI7XG4vLyBJbmNyZW1lbnQgYW4gQUVTLUNUUiBtb2RlIGNvdW50ZXIsIGludGVudGlvbmFsbHkgd3JhcHBpbmcvb3ZlcmZsb3dpbmdcbmZ1bmN0aW9uIGluY3JlbWVudENvdW50ZXIoY291bnRlcikge1xuICAgIGxldCBjYXJyeSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IGJsb2NrXzEuZGVmYXVsdC5TSVpFIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY2FycnkgKz0gKGNvdW50ZXIuZGF0YVtpXSAmIDB4ZmYpIHwgMDtcbiAgICAgICAgY291bnRlci5kYXRhW2ldID0gY2FycnkgJiAweGZmO1xuICAgICAgICBjYXJyeSA+Pj49IDg7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/providers/polyfill/aes_ctr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/providers/webcrypto.js":
/*!***************************************************************!*\
  !*** ./node_modules/miscreant/release/providers/webcrypto.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst exceptions_1 = __webpack_require__(/*! ../exceptions */ \"(rsc)/./node_modules/miscreant/release/exceptions.js\");\nconst aes_1 = __webpack_require__(/*! ./webcrypto/aes */ \"(rsc)/./node_modules/miscreant/release/providers/webcrypto/aes.js\");\nconst aes_ctr_1 = __webpack_require__(/*! ./webcrypto/aes_ctr */ \"(rsc)/./node_modules/miscreant/release/providers/webcrypto/aes_ctr.js\");\n/** Placeholder backend for using pure JavaScript crypto implementations */\nclass WebCryptoProvider {\n    constructor(crypto = window.crypto) {\n        this.crypto = crypto;\n    }\n    importBlockCipherKey(keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return aes_1.default.importKey(this.crypto, keyData);\n        });\n    }\n    importCTRKey(keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield aes_ctr_1.default.importKey(this.crypto, keyData);\n            }\n            catch (e) {\n                if (e.message.includes(\"unsupported\")) {\n                    throw new exceptions_1.NotImplementedError(\"WebCryptoProvider: AES-CTR unsupported. Use PolyfillCryptoProvider.\");\n                }\n                else {\n                    throw e;\n                }\n            }\n        });\n    }\n}\nexports.WebCryptoProvider = WebCryptoProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3dlYmNyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0MsaUVBQWlFLHdCQUF3QjtBQUN6SDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBZTtBQUM1QyxjQUFjLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLGtHQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWNvbXBvbmVudHMtcXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pc2NyZWFudC9yZWxlYXNlL3Byb3ZpZGVycy93ZWJjcnlwdG8uanM/NGU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4uL2V4Y2VwdGlvbnNcIik7XG5jb25zdCBhZXNfMSA9IHJlcXVpcmUoXCIuL3dlYmNyeXB0by9hZXNcIik7XG5jb25zdCBhZXNfY3RyXzEgPSByZXF1aXJlKFwiLi93ZWJjcnlwdG8vYWVzX2N0clwiKTtcbi8qKiBQbGFjZWhvbGRlciBiYWNrZW5kIGZvciB1c2luZyBwdXJlIEphdmFTY3JpcHQgY3J5cHRvIGltcGxlbWVudGF0aW9ucyAqL1xuY2xhc3MgV2ViQ3J5cHRvUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNyeXB0byA9IHdpbmRvdy5jcnlwdG8pIHtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSBjcnlwdG87XG4gICAgfVxuICAgIGltcG9ydEJsb2NrQ2lwaGVyS2V5KGtleURhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZXNfMS5kZWZhdWx0LmltcG9ydEtleSh0aGlzLmNyeXB0bywga2V5RGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbXBvcnRDVFJLZXkoa2V5RGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgYWVzX2N0cl8xLmRlZmF1bHQuaW1wb3J0S2V5KHRoaXMuY3J5cHRvLCBrZXlEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcInVuc3VwcG9ydGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcIldlYkNyeXB0b1Byb3ZpZGVyOiBBRVMtQ1RSIHVuc3VwcG9ydGVkLiBVc2UgUG9seWZpbGxDcnlwdG9Qcm92aWRlci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJDcnlwdG9Qcm92aWRlciA9IFdlYkNyeXB0b1Byb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/providers/webcrypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/providers/webcrypto/aes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/miscreant/release/providers/webcrypto/aes.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst block_1 = __webpack_require__(/*! ../../internals/block */ \"(rsc)/./node_modules/miscreant/release/internals/block.js\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\nclass WebCryptoAes {\n    constructor(_crypto, _key) {\n        this._crypto = _crypto;\n        this._key = _key;\n        // An initialization vector of all zeros, exposing the raw AES function\n        this._iv = new block_1.default();\n        this._emptyPromise = Promise.resolve(this);\n    }\n    /**\n     * Create a new WebCryptoAes instance\n     *\n     * @param {Crypto} crypto - the Web Cryptography provider\n     * @param {Uint8Array} keyData - the AES secret key\n     * @returns {Promise<WebCryptoAes}\n     */\n    static importKey(crypto, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Only AES-128 and AES-256 supported. AES-192 is not.\n            if (keyData.length !== 16 && keyData.length !== 32) {\n                throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n            }\n            const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n            return new WebCryptoAes(crypto, key);\n        });\n    }\n    /**\n     * Cleans expanded keys from memory, setting them to zeros.\n     */\n    clear() {\n        // TODO: perhaps we should clear something, but what, and how?\n        return this;\n    }\n    /**\n     * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n     *\n     * @param {Block} block - block to be encrypted in-place\n     * @returns {Promise<this>}\n     */\n    encryptBlock(block) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = { name: \"AES-CBC\", iv: this._iv.data };\n            const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data);\n            // TODO: a more efficient way to do in-place encryption?\n            block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n            return this._emptyPromise;\n        });\n    }\n}\nexports[\"default\"] = WebCryptoAes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3dlYmNyeXB0by9hZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHdGQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3dlYmNyeXB0by9hZXMuanM/ZTg1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoQykgMjAxNyBUb255IEFyY2llcmlcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBibG9ja18xID0gcmVxdWlyZShcIi4uLy4uL2ludGVybmFscy9ibG9ja1wiKTtcbi8qKlxuICogV2ViQ3J5cHRvLWJhc2VkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBRVMgYmxvY2sgY2lwaGVyLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gKGFiKXVzZXMgQUVTLUNCQyBtb2RlIHRvIGltcGxlbWVudCBBRVMtRUNCLiBUaGlzIGlzXG4gKiBsaWtlbHkgdG8gYmUgcmF0aGVyIHNsb3csIGFzIGl0IHJlcXVpcmVzIGFuIGFzeW5jIGNhbGwgcGVyIGJsb2NrLCBhbmRcbiAqIGRpc2NhcmRzIGhhbGYgdGhlIGJ1ZmZlci5cbiAqXG4gKiBJbiB0aGVvcnkgaXQgc2hvdWxkIGJlIGNvbnN0YW50IHRpbWUgZHVlIHRvIHRoZSB1c2Ugb2YgV2ViQ3J5cHRvIChwcm92aWRlZFxuICogdGhlIGJyb3dzZXIncyBpbXBsZW1lbnRhdGlvbiBpcyBjb25zdGFudCB0aW1lKSwgYnV0IGl0IGNvdWxkIHByb2JhYmx5IGJlbmVmaXRcbiAqIGZyb20gc29tZSBjbGV2ZXIgb3B0aW1pemF0aW9uIHdvcmssIG9yIGltcHJvdmVtZW50cyB0byB0aGUgV2ViQ3J5cHRvIEFQSS5cbiAqXG4gKiBTb21lIFdlYkNyeXB0byBpbXBsZW1lbnRhdGlvbnMgKGUuZy4gbm9kZS13ZWJjcnlwdG8tb3NzbCkgc3VwcG9ydCBFQ0IgbW9kZVxuICogbmF0aXZlbHksIHNvIHdlIGNvdWxkIHRha2UgYWR2YW50YWdlIG9mIHRoYXQgdG8gcG90ZW50aWFsbHkgZW5jcnlwdCBtdWx0aXBsZVxuICogYmxvY2tzIGluIGEgc2luZ2xlIGludm9jYXRpb24uXG4gKlxuICogS2V5IHNpemU6IDE2IG9yIDMyIGJ5dGVzLCBibG9jayBzaXplOiAxNiBieXRlcy5cbiAqL1xuY2xhc3MgV2ViQ3J5cHRvQWVzIHtcbiAgICBjb25zdHJ1Y3RvcihfY3J5cHRvLCBfa2V5KSB7XG4gICAgICAgIHRoaXMuX2NyeXB0byA9IF9jcnlwdG87XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIC8vIEFuIGluaXRpYWxpemF0aW9uIHZlY3RvciBvZiBhbGwgemVyb3MsIGV4cG9zaW5nIHRoZSByYXcgQUVTIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX2l2ID0gbmV3IGJsb2NrXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9lbXB0eVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBXZWJDcnlwdG9BZXMgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvfSBjcnlwdG8gLSB0aGUgV2ViIENyeXB0b2dyYXBoeSBwcm92aWRlclxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5RGF0YSAtIHRoZSBBRVMgc2VjcmV0IGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYkNyeXB0b0Flc31cbiAgICAgKi9cbiAgICBzdGF0aWMgaW1wb3J0S2V5KGNyeXB0bywga2V5RGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gT25seSBBRVMtMTI4IGFuZCBBRVMtMjU2IHN1cHBvcnRlZC4gQUVTLTE5MiBpcyBub3QuXG4gICAgICAgICAgICBpZiAoa2V5RGF0YS5sZW5ndGggIT09IDE2ICYmIGtleURhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzY3JlYW50OiBpbnZhbGlkIGtleSBsZW5ndGg6ICR7a2V5RGF0YS5sZW5ndGh9IChleHBlY3RlZCAxNiBvciAzMiBieXRlcylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleURhdGEsIFwiQUVTLUNCQ1wiLCBmYWxzZSwgW1wiZW5jcnlwdFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkNyeXB0b0FlcyhjcnlwdG8sIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgZXhwYW5kZWQga2V5cyBmcm9tIG1lbW9yeSwgc2V0dGluZyB0aGVtIHRvIHplcm9zLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICAvLyBUT0RPOiBwZXJoYXBzIHdlIHNob3VsZCBjbGVhciBzb21ldGhpbmcsIGJ1dCB3aGF0LCBhbmQgaG93P1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBhIHNpbmdsZSBBRVMgYmxvY2suIFdoaWxlIG9yZGluYXJpbHkgdGhpcyBtaWdodCBsZXQgdXMgc2VlIHBlbmd1aW5zLCB3ZSdyZSB1c2luZyBpdCBzYWZlbHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gYmxvY2sgdG8gYmUgZW5jcnlwdGVkIGluLXBsYWNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgZW5jcnlwdEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IG5hbWU6IFwiQUVTLUNCQ1wiLCBpdjogdGhpcy5faXYuZGF0YSB9O1xuICAgICAgICAgICAgY29uc3QgY3RCbG9jayA9IHlpZWxkIHRoaXMuX2NyeXB0by5zdWJ0bGUuZW5jcnlwdChwYXJhbXMsIHRoaXMuX2tleSwgYmxvY2suZGF0YSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyBpbi1wbGFjZSBlbmNyeXB0aW9uP1xuICAgICAgICAgICAgYmxvY2suZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoY3RCbG9jaywgMCwgYmxvY2tfMS5kZWZhdWx0LlNJWkUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbXB0eVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFdlYkNyeXB0b0FlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/providers/webcrypto/aes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/providers/webcrypto/aes_ctr.js":
/*!***********************************************************************!*\
  !*** ./node_modules/miscreant/release/providers/webcrypto/aes_ctr.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * AES-CTR using a WebCrypto (or similar) API\n */\nclass WebCryptoAesCtr {\n    constructor(key, crypto) {\n        this.key = key;\n        this.crypto = crypto;\n    }\n    static importKey(crypto, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Only AES-128 and AES-256 supported. AES-192 is not.\n            if (keyData.length !== 16 && keyData.length !== 32) {\n                throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n            }\n            const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CTR\", false, [\"encrypt\"]);\n            return new WebCryptoAesCtr(key, crypto);\n        });\n    }\n    encryptCtr(iv, plaintext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ciphertext = yield this.crypto.subtle.encrypt({ name: \"AES-CTR\", counter: iv, length: 16 }, this.key, plaintext);\n            return new Uint8Array(ciphertext);\n        });\n    }\n    clear() {\n        // TODO: actually clear something. Do we need to?\n        return this;\n    }\n}\nexports[\"default\"] = WebCryptoAesCtr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2UvcHJvdmlkZXJzL3dlYmNyeXB0by9hZXNfY3RyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwwQ0FBMEM7QUFDNUc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taXNjcmVhbnQvcmVsZWFzZS9wcm92aWRlcnMvd2ViY3J5cHRvL2Flc19jdHIuanM/ZGNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBRVMtQ1RSIHVzaW5nIGEgV2ViQ3J5cHRvIChvciBzaW1pbGFyKSBBUElcbiAqL1xuY2xhc3MgV2ViQ3J5cHRvQWVzQ3RyIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGNyeXB0bykge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSBjcnlwdG87XG4gICAgfVxuICAgIHN0YXRpYyBpbXBvcnRLZXkoY3J5cHRvLCBrZXlEYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IEFFUy0xMjggYW5kIEFFUy0yNTYgc3VwcG9ydGVkLiBBRVMtMTkyIGlzIG5vdC5cbiAgICAgICAgICAgIGlmIChrZXlEYXRhLmxlbmd0aCAhPT0gMTYgJiYga2V5RGF0YS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNjcmVhbnQ6IGludmFsaWQga2V5IGxlbmd0aDogJHtrZXlEYXRhLmxlbmd0aH0gKGV4cGVjdGVkIDE2IG9yIDMyIGJ5dGVzKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwga2V5RGF0YSwgXCJBRVMtQ1RSXCIsIGZhbHNlLCBbXCJlbmNyeXB0XCJdKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQ3J5cHRvQWVzQ3RyKGtleSwgY3J5cHRvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuY3J5cHRDdHIoaXYsIHBsYWludGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IHlpZWxkIHRoaXMuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KHsgbmFtZTogXCJBRVMtQ1RSXCIsIGNvdW50ZXI6IGl2LCBsZW5ndGg6IDE2IH0sIHRoaXMua2V5LCBwbGFpbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIC8vIFRPRE86IGFjdHVhbGx5IGNsZWFyIHNvbWV0aGluZy4gRG8gd2UgbmVlZCB0bz9cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViQ3J5cHRvQWVzQ3RyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/providers/webcrypto/aes_ctr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/siv.js":
/*!***********************************************!*\
  !*** ./node_modules/miscreant/release/siv.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright (C) 2017-2018 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst constant_time_1 = __webpack_require__(/*! ./internals/constant-time */ \"(rsc)/./node_modules/miscreant/release/internals/constant-time.js\");\nconst wipe_1 = __webpack_require__(/*! ./internals/wipe */ \"(rsc)/./node_modules/miscreant/release/internals/wipe.js\");\nconst xor_1 = __webpack_require__(/*! ./internals/xor */ \"(rsc)/./node_modules/miscreant/release/internals/xor.js\");\nconst exceptions_1 = __webpack_require__(/*! ./exceptions */ \"(rsc)/./node_modules/miscreant/release/exceptions.js\");\nconst block_1 = __webpack_require__(/*! ./internals/block */ \"(rsc)/./node_modules/miscreant/release/internals/block.js\");\nconst cmac_1 = __webpack_require__(/*! ./mac/cmac */ \"(rsc)/./node_modules/miscreant/release/mac/cmac.js\");\nconst pmac_1 = __webpack_require__(/*! ./mac/pmac */ \"(rsc)/./node_modules/miscreant/release/mac/pmac.js\");\nconst webcrypto_1 = __webpack_require__(/*! ./providers/webcrypto */ \"(rsc)/./node_modules/miscreant/release/providers/webcrypto.js\");\n/** Maximum number of associated data items */\nexports.MAX_ASSOCIATED_DATA = 126;\n/** The AES-SIV mode of authenticated encryption */\nclass SIV {\n    /** Create a new AES-SIV instance with the given 32-byte or 64-byte key */\n    static importKey(keyData, alg, provider = new webcrypto_1.WebCryptoProvider()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // We only support AES-128 and AES-256. AES-SIV needs a key 2X as long the intended security level\n            if (keyData.length !== 32 && keyData.length !== 64) {\n                throw new Error(`AES-SIV: key must be 32 or 64-bytes (got ${keyData.length}`);\n            }\n            const macKey = keyData.subarray(0, keyData.length / 2 | 0);\n            const encKey = keyData.subarray(keyData.length / 2 | 0);\n            let mac;\n            switch (alg) {\n                case \"AES-SIV\":\n                    mac = yield cmac_1.CMAC.importKey(provider, macKey);\n                    break;\n                case \"AES-CMAC-SIV\":\n                    mac = yield cmac_1.CMAC.importKey(provider, macKey);\n                    break;\n                case \"AES-PMAC-SIV\":\n                    mac = yield pmac_1.PMAC.importKey(provider, macKey);\n                    break;\n                default:\n                    throw new exceptions_1.NotImplementedError(`Miscreant: algorithm not supported: ${alg}`);\n            }\n            const ctr = yield provider.importCTRKey(encKey);\n            return new SIV(mac, ctr);\n        });\n    }\n    constructor(mac, ctr) {\n        this._mac = mac;\n        this._ctr = ctr;\n        this._tmp1 = new block_1.default();\n        this._tmp2 = new block_1.default();\n    }\n    /** Encrypt and authenticate data using AES-SIV */\n    seal(plaintext, associatedData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (associatedData.length > exports.MAX_ASSOCIATED_DATA) {\n                throw new Error(\"AES-SIV: too many associated data items\");\n            }\n            // Allocate space for sealed ciphertext.\n            const resultLength = block_1.default.SIZE + plaintext.length;\n            const result = new Uint8Array(resultLength);\n            // Authenticate.\n            const iv = yield this._s2v(associatedData, plaintext);\n            result.set(iv);\n            // Encrypt.\n            zeroIVBits(iv);\n            result.set(yield this._ctr.encryptCtr(iv, plaintext), iv.length);\n            return result;\n        });\n    }\n    /** Decrypt and authenticate data using AES-SIV */\n    open(sealed, associatedData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (associatedData.length > exports.MAX_ASSOCIATED_DATA) {\n                throw new Error(\"AES-SIV: too many associated data items\");\n            }\n            if (sealed.length < block_1.default.SIZE) {\n                throw new exceptions_1.IntegrityError(\"AES-SIV: ciphertext is truncated\");\n            }\n            // Decrypt.\n            const tag = sealed.subarray(0, block_1.default.SIZE);\n            const iv = this._tmp1.data;\n            iv.set(tag);\n            zeroIVBits(iv);\n            // NOTE: \"encryptCtr\" is intentional. CTR encryption/decryption are the same\n            const result = yield this._ctr.encryptCtr(iv, sealed.subarray(block_1.default.SIZE));\n            // Authenticate.\n            const expectedTag = yield this._s2v(associatedData, result);\n            if (!constant_time_1.equal(expectedTag, tag)) {\n                wipe_1.wipe(result);\n                throw new exceptions_1.IntegrityError(\"AES-SIV: ciphertext verification failure!\");\n            }\n            return result;\n        });\n    }\n    /** Make a best effort to wipe memory used by this instance */\n    clear() {\n        this._tmp1.clear();\n        this._tmp2.clear();\n        this._ctr.clear();\n        this._mac.clear();\n        return this;\n    }\n    /**\n     * The S2V operation consists of the doubling and XORing of the outputs\n     * of the pseudo-random function CMAC (or PMAC in the case of AES-PMAC-SIV).\n     *\n     * See Section 2.4 of RFC 5297 for more information\n     */\n    _s2v(associated_data, plaintext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._mac.reset();\n            this._tmp1.clear();\n            // Note: the standalone S2V returns CMAC(1) if the number of passed\n            // vectors is zero, however in SIV construction this case is never\n            // triggered, since we always pass plaintext as the last vector (even\n            // if it's zero-length), so we omit this case.\n            yield this._mac.update(this._tmp1.data);\n            this._tmp2.clear();\n            this._tmp2.data.set(yield this._mac.finish());\n            this._mac.reset();\n            for (const ad of associated_data) {\n                yield this._mac.update(ad);\n                this._tmp1.clear();\n                this._tmp1.data.set(yield this._mac.finish());\n                this._mac.reset();\n                this._tmp2.dbl();\n                xor_1.xor(this._tmp2.data, this._tmp1.data);\n            }\n            this._tmp1.clear();\n            if (plaintext.length >= block_1.default.SIZE) {\n                const n = plaintext.length - block_1.default.SIZE;\n                this._tmp1.data.set(plaintext.subarray(n));\n                yield this._mac.update(plaintext.subarray(0, n));\n            }\n            else {\n                this._tmp1.data.set(plaintext);\n                this._tmp1.data[plaintext.length] = 0x80;\n                this._tmp2.dbl();\n            }\n            xor_1.xor(this._tmp1.data, this._tmp2.data);\n            yield this._mac.update(this._tmp1.data);\n            return this._mac.finish();\n        });\n    }\n}\nexports.SIV = SIV;\n/** Zero out the top bits in the last 32-bit words of the IV */\nfunction zeroIVBits(iv) {\n    // \"We zero-out the top bit in each of the last two 32-bit words\n    // of the IV before assigning it to Ctr\"\n    //  — http://web.cs.ucdavis.edu/~rogaway/papers/siv.pdf\n    iv[iv.length - 8] &= 0x7f;\n    iv[iv.length - 4] &= 0x7f;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2Uvc2l2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0MsaUVBQWlFLHdCQUF3QjtBQUN6SDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyxvR0FBMkI7QUFDM0QsZUFBZSxtQkFBTyxDQUFDLGtGQUFrQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLDBFQUFjO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFtQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsc0VBQVk7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHNFQUFZO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNuRDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxJQUFJO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1jb21wb25lbnRzLXFzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taXNjcmVhbnQvcmVsZWFzZS9zaXYuanM/YTJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoQykgMjAxNy0yMDE4IERtaXRyeSBDaGVzdG55a2gsIFRvbnkgQXJjaWVyaVxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnN0YW50X3RpbWVfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9jb25zdGFudC10aW1lXCIpO1xuY29uc3Qgd2lwZV8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL3dpcGVcIik7XG5jb25zdCB4b3JfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy94b3JcIik7XG5jb25zdCBleGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi9leGNlcHRpb25zXCIpO1xuY29uc3QgYmxvY2tfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9ibG9ja1wiKTtcbmNvbnN0IGNtYWNfMSA9IHJlcXVpcmUoXCIuL21hYy9jbWFjXCIpO1xuY29uc3QgcG1hY18xID0gcmVxdWlyZShcIi4vbWFjL3BtYWNcIik7XG5jb25zdCB3ZWJjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy93ZWJjcnlwdG9cIik7XG4vKiogTWF4aW11bSBudW1iZXIgb2YgYXNzb2NpYXRlZCBkYXRhIGl0ZW1zICovXG5leHBvcnRzLk1BWF9BU1NPQ0lBVEVEX0RBVEEgPSAxMjY7XG4vKiogVGhlIEFFUy1TSVYgbW9kZSBvZiBhdXRoZW50aWNhdGVkIGVuY3J5cHRpb24gKi9cbmNsYXNzIFNJViB7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBBRVMtU0lWIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIDMyLWJ5dGUgb3IgNjQtYnl0ZSBrZXkgKi9cbiAgICBzdGF0aWMgaW1wb3J0S2V5KGtleURhdGEsIGFsZywgcHJvdmlkZXIgPSBuZXcgd2ViY3J5cHRvXzEuV2ViQ3J5cHRvUHJvdmlkZXIoKSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IEFFUy0xMjggYW5kIEFFUy0yNTYuIEFFUy1TSVYgbmVlZHMgYSBrZXkgMlggYXMgbG9uZyB0aGUgaW50ZW5kZWQgc2VjdXJpdHkgbGV2ZWxcbiAgICAgICAgICAgIGlmIChrZXlEYXRhLmxlbmd0aCAhPT0gMzIgJiYga2V5RGF0YS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRVMtU0lWOiBrZXkgbXVzdCBiZSAzMiBvciA2NC1ieXRlcyAoZ290ICR7a2V5RGF0YS5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYWNLZXkgPSBrZXlEYXRhLnN1YmFycmF5KDAsIGtleURhdGEubGVuZ3RoIC8gMiB8IDApO1xuICAgICAgICAgICAgY29uc3QgZW5jS2V5ID0ga2V5RGF0YS5zdWJhcnJheShrZXlEYXRhLmxlbmd0aCAvIDIgfCAwKTtcbiAgICAgICAgICAgIGxldCBtYWM7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBRVMtU0lWXCI6XG4gICAgICAgICAgICAgICAgICAgIG1hYyA9IHlpZWxkIGNtYWNfMS5DTUFDLmltcG9ydEtleShwcm92aWRlciwgbWFjS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFFUy1DTUFDLVNJVlwiOlxuICAgICAgICAgICAgICAgICAgICBtYWMgPSB5aWVsZCBjbWFjXzEuQ01BQy5pbXBvcnRLZXkocHJvdmlkZXIsIG1hY0tleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBRVMtUE1BQy1TSVZcIjpcbiAgICAgICAgICAgICAgICAgICAgbWFjID0geWllbGQgcG1hY18xLlBNQUMuaW1wb3J0S2V5KHByb3ZpZGVyLCBtYWNLZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLk5vdEltcGxlbWVudGVkRXJyb3IoYE1pc2NyZWFudDogYWxnb3JpdGhtIG5vdCBzdXBwb3J0ZWQ6ICR7YWxnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3RyID0geWllbGQgcHJvdmlkZXIuaW1wb3J0Q1RSS2V5KGVuY0tleSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNJVihtYWMsIGN0cik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtYWMsIGN0cikge1xuICAgICAgICB0aGlzLl9tYWMgPSBtYWM7XG4gICAgICAgIHRoaXMuX2N0ciA9IGN0cjtcbiAgICAgICAgdGhpcy5fdG1wMSA9IG5ldyBibG9ja18xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fdG1wMiA9IG5ldyBibG9ja18xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIEVuY3J5cHQgYW5kIGF1dGhlbnRpY2F0ZSBkYXRhIHVzaW5nIEFFUy1TSVYgKi9cbiAgICBzZWFsKHBsYWludGV4dCwgYXNzb2NpYXRlZERhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhc3NvY2lhdGVkRGF0YS5sZW5ndGggPiBleHBvcnRzLk1BWF9BU1NPQ0lBVEVEX0RBVEEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRVMtU0lWOiB0b28gbWFueSBhc3NvY2lhdGVkIGRhdGEgaXRlbXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGxvY2F0ZSBzcGFjZSBmb3Igc2VhbGVkIGNpcGhlcnRleHQuXG4gICAgICAgICAgICBjb25zdCByZXN1bHRMZW5ndGggPSBibG9ja18xLmRlZmF1bHQuU0laRSArIHBsYWludGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShyZXN1bHRMZW5ndGgpO1xuICAgICAgICAgICAgLy8gQXV0aGVudGljYXRlLlxuICAgICAgICAgICAgY29uc3QgaXYgPSB5aWVsZCB0aGlzLl9zMnYoYXNzb2NpYXRlZERhdGEsIHBsYWludGV4dCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGl2KTtcbiAgICAgICAgICAgIC8vIEVuY3J5cHQuXG4gICAgICAgICAgICB6ZXJvSVZCaXRzKGl2KTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoeWllbGQgdGhpcy5fY3RyLmVuY3J5cHRDdHIoaXYsIHBsYWludGV4dCksIGl2Lmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIERlY3J5cHQgYW5kIGF1dGhlbnRpY2F0ZSBkYXRhIHVzaW5nIEFFUy1TSVYgKi9cbiAgICBvcGVuKHNlYWxlZCwgYXNzb2NpYXRlZERhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhc3NvY2lhdGVkRGF0YS5sZW5ndGggPiBleHBvcnRzLk1BWF9BU1NPQ0lBVEVEX0RBVEEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRVMtU0lWOiB0b28gbWFueSBhc3NvY2lhdGVkIGRhdGEgaXRlbXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VhbGVkLmxlbmd0aCA8IGJsb2NrXzEuZGVmYXVsdC5TSVpFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5JbnRlZ3JpdHlFcnJvcihcIkFFUy1TSVY6IGNpcGhlcnRleHQgaXMgdHJ1bmNhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjcnlwdC5cbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHNlYWxlZC5zdWJhcnJheSgwLCBibG9ja18xLmRlZmF1bHQuU0laRSk7XG4gICAgICAgICAgICBjb25zdCBpdiA9IHRoaXMuX3RtcDEuZGF0YTtcbiAgICAgICAgICAgIGl2LnNldCh0YWcpO1xuICAgICAgICAgICAgemVyb0lWQml0cyhpdik7XG4gICAgICAgICAgICAvLyBOT1RFOiBcImVuY3J5cHRDdHJcIiBpcyBpbnRlbnRpb25hbC4gQ1RSIGVuY3J5cHRpb24vZGVjcnlwdGlvbiBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuX2N0ci5lbmNyeXB0Q3RyKGl2LCBzZWFsZWQuc3ViYXJyYXkoYmxvY2tfMS5kZWZhdWx0LlNJWkUpKTtcbiAgICAgICAgICAgIC8vIEF1dGhlbnRpY2F0ZS5cbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVGFnID0geWllbGQgdGhpcy5fczJ2KGFzc29jaWF0ZWREYXRhLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCFjb25zdGFudF90aW1lXzEuZXF1YWwoZXhwZWN0ZWRUYWcsIHRhZykpIHtcbiAgICAgICAgICAgICAgICB3aXBlXzEud2lwZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuSW50ZWdyaXR5RXJyb3IoXCJBRVMtU0lWOiBjaXBoZXJ0ZXh0IHZlcmlmaWNhdGlvbiBmYWlsdXJlIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogTWFrZSBhIGJlc3QgZWZmb3J0IHRvIHdpcGUgbWVtb3J5IHVzZWQgYnkgdGhpcyBpbnN0YW5jZSAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl90bXAxLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3RtcDIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fY3RyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hYy5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIFMyViBvcGVyYXRpb24gY29uc2lzdHMgb2YgdGhlIGRvdWJsaW5nIGFuZCBYT1Jpbmcgb2YgdGhlIG91dHB1dHNcbiAgICAgKiBvZiB0aGUgcHNldWRvLXJhbmRvbSBmdW5jdGlvbiBDTUFDIChvciBQTUFDIGluIHRoZSBjYXNlIG9mIEFFUy1QTUFDLVNJVikuXG4gICAgICpcbiAgICAgKiBTZWUgU2VjdGlvbiAyLjQgb2YgUkZDIDUyOTcgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfczJ2KGFzc29jaWF0ZWRfZGF0YSwgcGxhaW50ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RtcDEuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBzdGFuZGFsb25lIFMyViByZXR1cm5zIENNQUMoMSkgaWYgdGhlIG51bWJlciBvZiBwYXNzZWRcbiAgICAgICAgICAgIC8vIHZlY3RvcnMgaXMgemVybywgaG93ZXZlciBpbiBTSVYgY29uc3RydWN0aW9uIHRoaXMgY2FzZSBpcyBuZXZlclxuICAgICAgICAgICAgLy8gdHJpZ2dlcmVkLCBzaW5jZSB3ZSBhbHdheXMgcGFzcyBwbGFpbnRleHQgYXMgdGhlIGxhc3QgdmVjdG9yIChldmVuXG4gICAgICAgICAgICAvLyBpZiBpdCdzIHplcm8tbGVuZ3RoKSwgc28gd2Ugb21pdCB0aGlzIGNhc2UuXG4gICAgICAgICAgICB5aWVsZCB0aGlzLl9tYWMudXBkYXRlKHRoaXMuX3RtcDEuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl90bXAyLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl90bXAyLmRhdGEuc2V0KHlpZWxkIHRoaXMuX21hYy5maW5pc2goKSk7XG4gICAgICAgICAgICB0aGlzLl9tYWMucmVzZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWQgb2YgYXNzb2NpYXRlZF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fbWFjLnVwZGF0ZShhZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG1wMS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RtcDEuZGF0YS5zZXQoeWllbGQgdGhpcy5fbWFjLmZpbmlzaCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90bXAyLmRibCgpO1xuICAgICAgICAgICAgICAgIHhvcl8xLnhvcih0aGlzLl90bXAyLmRhdGEsIHRoaXMuX3RtcDEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90bXAxLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCA+PSBibG9ja18xLmRlZmF1bHQuU0laRSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBwbGFpbnRleHQubGVuZ3RoIC0gYmxvY2tfMS5kZWZhdWx0LlNJWkU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG1wMS5kYXRhLnNldChwbGFpbnRleHQuc3ViYXJyYXkobikpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX21hYy51cGRhdGUocGxhaW50ZXh0LnN1YmFycmF5KDAsIG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RtcDEuZGF0YS5zZXQocGxhaW50ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90bXAxLmRhdGFbcGxhaW50ZXh0Lmxlbmd0aF0gPSAweDgwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RtcDIuZGJsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4b3JfMS54b3IodGhpcy5fdG1wMS5kYXRhLCB0aGlzLl90bXAyLmRhdGEpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fbWFjLnVwZGF0ZSh0aGlzLl90bXAxLmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hYy5maW5pc2goKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TSVYgPSBTSVY7XG4vKiogWmVybyBvdXQgdGhlIHRvcCBiaXRzIGluIHRoZSBsYXN0IDMyLWJpdCB3b3JkcyBvZiB0aGUgSVYgKi9cbmZ1bmN0aW9uIHplcm9JVkJpdHMoaXYpIHtcbiAgICAvLyBcIldlIHplcm8tb3V0IHRoZSB0b3AgYml0IGluIGVhY2ggb2YgdGhlIGxhc3QgdHdvIDMyLWJpdCB3b3Jkc1xuICAgIC8vIG9mIHRoZSBJViBiZWZvcmUgYXNzaWduaW5nIGl0IHRvIEN0clwiXG4gICAgLy8gIOKAlCBodHRwOi8vd2ViLmNzLnVjZGF2aXMuZWR1L35yb2dhd2F5L3BhcGVycy9zaXYucGRmXG4gICAgaXZbaXYubGVuZ3RoIC0gOF0gJj0gMHg3ZjtcbiAgICBpdltpdi5sZW5ndGggLSA0XSAmPSAweDdmO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/siv.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/miscreant/release/stream.js":
/*!**************************************************!*\
  !*** ./node_modules/miscreant/release/stream.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * The STREAM online authenticated encryption construction.\n * See <https://eprint.iacr.org/2015/189.pdf> for definition.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst aead_1 = __webpack_require__(/*! ./aead */ \"(rsc)/./node_modules/miscreant/release/aead.js\");\nconst webcrypto_1 = __webpack_require__(/*! ./providers/webcrypto */ \"(rsc)/./node_modules/miscreant/release/providers/webcrypto.js\");\n/** Size of a nonce required by STREAM in bytes */\nexports.NONCE_SIZE = 8;\n/** Byte flag indicating this is the last block in the STREAM (otherwise 0) */\nexports.LAST_BLOCK_FLAG = 1;\n/** Maximum value of the counter STREAM uses internally to identify messages */\nexports.COUNTER_MAX = 0xFFFFFFFF;\n/**\n * A STREAM encryptor with a 32-bit counter, generalized for any AEAD algorithm\n *\n * This corresponds to the ℰ stream encryptor object as defined in the paper\n * Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance\n */\nclass StreamEncryptor {\n    /** Create a new StreamEncryptor instance with the given key */\n    static importKey(keyData, nonce, alg, provider = new webcrypto_1.WebCryptoProvider()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new StreamEncryptor(yield aead_1.AEAD.importKey(keyData, alg, provider), nonce);\n        });\n    }\n    constructor(aead, nonce) {\n        this._aead = aead;\n        this._nonce_encoder = new NonceEncoder(nonce);\n    }\n    /** Encrypt and authenticate data using the selected AEAD algorithm */\n    seal(plaintext, lastBlock = false, associatedData = new Uint8Array(0)) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._aead.seal(plaintext, this._nonce_encoder.next(lastBlock), associatedData);\n        });\n    }\n    /** Make a best effort to wipe memory used by this instance */\n    clear() {\n        this._aead.clear();\n        return this;\n    }\n}\nexports.StreamEncryptor = StreamEncryptor;\n/**\n * A STREAM decryptor with a 32-bit counter, generalized for any AEAD algorithm\n *\n * This corresponds to the 𝒟 stream decryptor object as defined in the paper\n * Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance\n */\nclass StreamDecryptor {\n    /** Create a new StreamDecryptor instance with the given key */\n    static importKey(keyData, nonce, alg, provider = new webcrypto_1.WebCryptoProvider()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new StreamDecryptor(yield aead_1.AEAD.importKey(keyData, alg, provider), nonce);\n        });\n    }\n    constructor(aead, nonce) {\n        this._aead = aead;\n        this._nonce_encoder = new NonceEncoder(nonce);\n    }\n    /** Decrypt and authenticate data using the selected AEAD algorithm */\n    open(ciphertext, lastBlock = false, associatedData = new Uint8Array(0)) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._aead.open(ciphertext, this._nonce_encoder.next(lastBlock), associatedData);\n        });\n    }\n    /** Make a best effort to wipe memory used by this instance */\n    clear() {\n        this._aead.clear();\n        return this;\n    }\n}\nexports.StreamDecryptor = StreamDecryptor;\n/** Computes STREAM nonces based on the current position in the STREAM. */\nclass NonceEncoder {\n    constructor(noncePrefix) {\n        if (noncePrefix.length !== exports.NONCE_SIZE) {\n            throw new Error(`STREAM: nonce must be 8-bits (got ${noncePrefix.length}`);\n        }\n        this.buffer = new ArrayBuffer(exports.NONCE_SIZE + 4 + 1);\n        this.view = new DataView(this.buffer);\n        this.array = new Uint8Array(this.buffer);\n        this.array.set(noncePrefix);\n        this.counter = 0;\n        this.finished = false;\n    }\n    /** Compute the next nonce value, incrementing the internal counter */\n    next(lastBlock) {\n        if (this.finished) {\n            throw new Error(\"STREAM: already finished\");\n        }\n        this.view.setInt32(8, this.counter, false);\n        if (lastBlock) {\n            this.view.setInt8(12, exports.LAST_BLOCK_FLAG);\n            this.finished = true;\n        }\n        else {\n            this.counter += 1;\n            if (this.counter > exports.COUNTER_MAX) {\n                throw new Error(\"STREAM counter overflowed\");\n            }\n        }\n        return this.array;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2Uvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDLGlFQUFpRSx3QkFBd0I7QUFDekg7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDhEQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNuRDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktY29tcG9uZW50cy1xcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWlzY3JlYW50L3JlbGVhc2Uvc3RyZWFtLmpzPzA4ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBTVFJFQU0gb25saW5lIGF1dGhlbnRpY2F0ZWQgZW5jcnlwdGlvbiBjb25zdHJ1Y3Rpb24uXG4gKiBTZWUgPGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTg5LnBkZj4gZm9yIGRlZmluaXRpb24uXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWVhZF8xID0gcmVxdWlyZShcIi4vYWVhZFwiKTtcbmNvbnN0IHdlYmNyeXB0b18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL3dlYmNyeXB0b1wiKTtcbi8qKiBTaXplIG9mIGEgbm9uY2UgcmVxdWlyZWQgYnkgU1RSRUFNIGluIGJ5dGVzICovXG5leHBvcnRzLk5PTkNFX1NJWkUgPSA4O1xuLyoqIEJ5dGUgZmxhZyBpbmRpY2F0aW5nIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgaW4gdGhlIFNUUkVBTSAob3RoZXJ3aXNlIDApICovXG5leHBvcnRzLkxBU1RfQkxPQ0tfRkxBRyA9IDE7XG4vKiogTWF4aW11bSB2YWx1ZSBvZiB0aGUgY291bnRlciBTVFJFQU0gdXNlcyBpbnRlcm5hbGx5IHRvIGlkZW50aWZ5IG1lc3NhZ2VzICovXG5leHBvcnRzLkNPVU5URVJfTUFYID0gMHhGRkZGRkZGRjtcbi8qKlxuICogQSBTVFJFQU0gZW5jcnlwdG9yIHdpdGggYSAzMi1iaXQgY291bnRlciwgZ2VuZXJhbGl6ZWQgZm9yIGFueSBBRUFEIGFsZ29yaXRobVxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIOKEsCBzdHJlYW0gZW5jcnlwdG9yIG9iamVjdCBhcyBkZWZpbmVkIGluIHRoZSBwYXBlclxuICogT25saW5lIEF1dGhlbnRpY2F0ZWQtRW5jcnlwdGlvbiBhbmQgaXRzIE5vbmNlLVJldXNlIE1pc3VzZS1SZXNpc3RhbmNlXG4gKi9cbmNsYXNzIFN0cmVhbUVuY3J5cHRvciB7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBTdHJlYW1FbmNyeXB0b3IgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4ga2V5ICovXG4gICAgc3RhdGljIGltcG9ydEtleShrZXlEYXRhLCBub25jZSwgYWxnLCBwcm92aWRlciA9IG5ldyB3ZWJjcnlwdG9fMS5XZWJDcnlwdG9Qcm92aWRlcigpKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUVuY3J5cHRvcih5aWVsZCBhZWFkXzEuQUVBRC5pbXBvcnRLZXkoa2V5RGF0YSwgYWxnLCBwcm92aWRlciksIG5vbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFlYWQsIG5vbmNlKSB7XG4gICAgICAgIHRoaXMuX2FlYWQgPSBhZWFkO1xuICAgICAgICB0aGlzLl9ub25jZV9lbmNvZGVyID0gbmV3IE5vbmNlRW5jb2Rlcihub25jZSk7XG4gICAgfVxuICAgIC8qKiBFbmNyeXB0IGFuZCBhdXRoZW50aWNhdGUgZGF0YSB1c2luZyB0aGUgc2VsZWN0ZWQgQUVBRCBhbGdvcml0aG0gKi9cbiAgICBzZWFsKHBsYWludGV4dCwgbGFzdEJsb2NrID0gZmFsc2UsIGFzc29jaWF0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoMCkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZWFkLnNlYWwocGxhaW50ZXh0LCB0aGlzLl9ub25jZV9lbmNvZGVyLm5leHQobGFzdEJsb2NrKSwgYXNzb2NpYXRlZERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIE1ha2UgYSBiZXN0IGVmZm9ydCB0byB3aXBlIG1lbW9yeSB1c2VkIGJ5IHRoaXMgaW5zdGFuY2UgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fYWVhZC5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbUVuY3J5cHRvciA9IFN0cmVhbUVuY3J5cHRvcjtcbi8qKlxuICogQSBTVFJFQU0gZGVjcnlwdG9yIHdpdGggYSAzMi1iaXQgY291bnRlciwgZ2VuZXJhbGl6ZWQgZm9yIGFueSBBRUFEIGFsZ29yaXRobVxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIPCdkp8gc3RyZWFtIGRlY3J5cHRvciBvYmplY3QgYXMgZGVmaW5lZCBpbiB0aGUgcGFwZXJcbiAqIE9ubGluZSBBdXRoZW50aWNhdGVkLUVuY3J5cHRpb24gYW5kIGl0cyBOb25jZS1SZXVzZSBNaXN1c2UtUmVzaXN0YW5jZVxuICovXG5jbGFzcyBTdHJlYW1EZWNyeXB0b3Ige1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgU3RyZWFtRGVjcnlwdG9yIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIGtleSAqL1xuICAgIHN0YXRpYyBpbXBvcnRLZXkoa2V5RGF0YSwgbm9uY2UsIGFsZywgcHJvdmlkZXIgPSBuZXcgd2ViY3J5cHRvXzEuV2ViQ3J5cHRvUHJvdmlkZXIoKSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1EZWNyeXB0b3IoeWllbGQgYWVhZF8xLkFFQUQuaW1wb3J0S2V5KGtleURhdGEsIGFsZywgcHJvdmlkZXIpLCBub25jZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhZWFkLCBub25jZSkge1xuICAgICAgICB0aGlzLl9hZWFkID0gYWVhZDtcbiAgICAgICAgdGhpcy5fbm9uY2VfZW5jb2RlciA9IG5ldyBOb25jZUVuY29kZXIobm9uY2UpO1xuICAgIH1cbiAgICAvKiogRGVjcnlwdCBhbmQgYXV0aGVudGljYXRlIGRhdGEgdXNpbmcgdGhlIHNlbGVjdGVkIEFFQUQgYWxnb3JpdGhtICovXG4gICAgb3BlbihjaXBoZXJ0ZXh0LCBsYXN0QmxvY2sgPSBmYWxzZSwgYXNzb2NpYXRlZERhdGEgPSBuZXcgVWludDhBcnJheSgwKSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FlYWQub3BlbihjaXBoZXJ0ZXh0LCB0aGlzLl9ub25jZV9lbmNvZGVyLm5leHQobGFzdEJsb2NrKSwgYXNzb2NpYXRlZERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIE1ha2UgYSBiZXN0IGVmZm9ydCB0byB3aXBlIG1lbW9yeSB1c2VkIGJ5IHRoaXMgaW5zdGFuY2UgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fYWVhZC5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbURlY3J5cHRvciA9IFN0cmVhbURlY3J5cHRvcjtcbi8qKiBDb21wdXRlcyBTVFJFQU0gbm9uY2VzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBTVFJFQU0uICovXG5jbGFzcyBOb25jZUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG5vbmNlUHJlZml4KSB7XG4gICAgICAgIGlmIChub25jZVByZWZpeC5sZW5ndGggIT09IGV4cG9ydHMuTk9OQ0VfU0laRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTVFJFQU06IG5vbmNlIG11c3QgYmUgOC1iaXRzIChnb3QgJHtub25jZVByZWZpeC5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZXhwb3J0cy5OT05DRV9TSVpFICsgNCArIDEpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmFycmF5LnNldChub25jZVByZWZpeCk7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqIENvbXB1dGUgdGhlIG5leHQgbm9uY2UgdmFsdWUsIGluY3JlbWVudGluZyB0aGUgaW50ZXJuYWwgY291bnRlciAqL1xuICAgIG5leHQobGFzdEJsb2NrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVFJFQU06IGFscmVhZHkgZmluaXNoZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnNldEludDMyKDgsIHRoaXMuY291bnRlciwgZmFsc2UpO1xuICAgICAgICBpZiAobGFzdEJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0SW50OCgxMiwgZXhwb3J0cy5MQVNUX0JMT0NLX0ZMQUcpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPiBleHBvcnRzLkNPVU5URVJfTUFYKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RSRUFNIGNvdW50ZXIgb3ZlcmZsb3dlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miscreant/release/stream.js\n");

/***/ })

};
;